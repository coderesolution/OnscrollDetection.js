{"version":3,"file":"OnscrollDetection.mjs","sources":["../src/index.js"],"sourcesContent":["export default class OnscrollDetection {\n\tconstructor(options = {}) {\n\t\t// Initialise class properties with default values or provided options\n\t\tthis.elements = options.elements || '[data-onscroll]'\n\t\tthis.screen = options.screen || '(min-width: 1025px)'\n\t\tthis.triggers = new Map()\n\n\t\t// Set class names to defaults or provided options\n\t\tthis.classDefaults = {\n\t\t\tscrollingClass: 'is-scrolling',\n\t\t\tscrolledClass: 'has-scrolled',\n\t\t\tstickyClass: 'is-sticky',\n\t\t\tstuckClass: 'has-stuck',\n\t\t\t...options.classDefaults,\n\t\t}\n\n\t\t// Initialise event handlers\n\t\tthis.eventHandlers = {}\n\n\t\t// Initialise the class\n\t\tthis.init()\n\t}\n\n\t// Initialisation function\n\tinit() {\n\t\t// Convert elements to an array and loop through each\n\t\tgsap.utils.toArray(this.elements).forEach((element, index) => {\n\t\t\t// Get the trigger element\n\t\t\tconst trigger = this.getTrigger(element)\n\n\t\t\t// Get the screen media query\n\t\t\tconst screen = this.getScreen(element)\n\n\t\t\t// Create a matchMedia instance\n\t\t\tconst matchMedia = gsap.matchMedia()\n\n\t\t\t// Get the animation properties for 'from' state\n\t\t\tconst fromProperties = this.getFromProperties(element, index)\n\n\t\t\t// Get the animation properties for 'to' state\n\t\t\tconst toProperties = this.getToProperties(element, index, trigger)\n\n\t\t\t// Add the animation to the matchMedia instance and store the ScrollTrigger instance\n\t\t\tconst animation = matchMedia.add(screen, () => {\n\t\t\t\tconst gsapAnimation = gsap.fromTo(element, fromProperties, toProperties)\n\n\t\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t\telement,\n\t\t\t\t\tfromProperties,\n\t\t\t\t\ttoProperties,\n\t\t\t\t\tgsapAnimation,\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// Enable debug mode for logging\n\t\t\tthis.debugMode(element, index)\n\t\t})\n\t}\n\n\t// Helper methods\n\ton(event, handler) {\n\t\tif (!this.eventHandlers[event]) {\n\t\t\tthis.eventHandlers[event] = []\n\t\t}\n\t\tthis.eventHandlers[event].push(handler)\n\t}\n\n\temit(event, ...args) {\n\t\tif (this.eventHandlers[event]) {\n\t\t\tthis.eventHandlers[event].forEach((handler) => handler(...args))\n\t\t}\n\t}\n\n\t// Get the trigger element for ScrollTrigger\n\tgetTrigger(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto']) && !element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-auto is present and data-onscroll-trigger is not, use the parent element as the trigger\n\t\t\treturn element.parentElement\n\t\t} else if (element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-trigger is present, try to find the DOM element specified by the attribute\n\t\t\tlet triggerElement = document.querySelector(element.dataset.onscrollTrigger)\n\t\t\tif (triggerElement) {\n\t\t\t\treturn triggerElement\n\t\t\t} else {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`Element specified by data-onscroll-trigger not found: ${element.dataset.onscrollTrigger}`\n\t\t\t\t)\n\t\t\t\treturn element\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise, use the element itself as the trigger\n\t\t\treturn element\n\t\t}\n\t}\n\n\t// Get the screen media query\n\tgetScreen(element) {\n\t\treturn element.hasAttribute('data-onscroll-screen') ? element.dataset.onscrollScreen : this.screen\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetFromProperties(element, index) {\n\t\tconst animateFrom = this.getAnimateFrom(element)\n\t\tconst { offset } = this.getOffsetAndDistance(element)\n\n\t\treturn {\n\t\t\t...animateFrom,\n\t\t\tbottom: this.hasAttributes(element, ['data-onscroll-auto', 'data-onscroll-reverse']) ? 'auto' : null,\n\t\t\ttop:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-auto']) &&\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-reverse'])\n\t\t\t\t\t? 'auto'\n\t\t\t\t\t: null,\n\t\t\tx:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t\ty:\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t}\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetToProperties(element, index, trigger) {\n\t\tconst animateTo = this.getAnimateTo(element)\n\t\tconst stickyProperties = this.getStickyProperties(element)\n\t\tconst isSticky = this.hasAttributes(element, ['data-onscroll-sticky'])\n\t\tconst customEventName = element.getAttribute('data-onscroll-call')\n\n\t\treturn {\n\t\t\t...animateTo,\n\t\t\tx: this.getX(element),\n\t\t\ty: this.getY(element),\n\t\t\tease: 'none',\n\t\t\tscrollTrigger: {\n\t\t\t\ttrigger: isSticky ? element : trigger,\n\t\t\t\tstart: this.getStart(element),\n\t\t\t\tend: this.getEnd(element),\n\t\t\t\tinvalidateOnRefresh: true,\n\t\t\t\tpin: stickyProperties.pin,\n\t\t\t\tpinSpacing: stickyProperties.pinSpacing,\n\t\t\t\tscrub: this.getScrub(element),\n\t\t\t\tmarkers: this.hasAttributes(element, ['data-onscroll-debug']),\n\t\t\t\tonEnter: ({ direction }) => {\n\t\t\t\t\telement.classList.add(this.classDefaults.scrollingClass, this.classDefaults.scrolledClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.add(this.classDefaults.stickyClass, this.classDefaults.stuckClass)\n\t\t\t\t\t}\n\t\t\t\t\tif (customEventName) {\n\t\t\t\t\t\t// Trigger custom event when the element enters the viewport\n\t\t\t\t\t\twindow.dispatchEvent(new CustomEvent(customEventName, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\ttarget: element,\n\t\t\t\t\t\t\t\tdirection: direction === 1 ? 'down' : 'up',\n\t\t\t\t\t\t\t\twhen: 'onEnter'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit('onEnter', element)\n\t\t\t\t},\n\t\t\t\tonLeave: ({ direction }) => {\n\t\t\t\t\telement.classList.remove(this.classDefaults.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.remove(this.classDefaults.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tif (customEventName) {\n\t\t\t\t\t\t// Trigger custom event when the element enters the viewport\n\t\t\t\t\t\twindow.dispatchEvent(new CustomEvent(customEventName, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\ttarget: element,\n\t\t\t\t\t\t\t\tdirection: direction === 1 ? 'down' : 'up',\n\t\t\t\t\t\t\t\twhen: 'onLeave'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit('onLeave', element)\n\t\t\t\t},\n\t\t\t\tonEnterBack: ({ direction }) => {\n\t\t\t\t\telement.classList.add(this.classDefaults.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.add(this.classDefaults.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tif (customEventName) {\n\t\t\t\t\t\t// Trigger custom event when the element enters the viewport\n\t\t\t\t\t\twindow.dispatchEvent(new CustomEvent(customEventName, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\ttarget: element,\n\t\t\t\t\t\t\t\tdirection: direction === 1 ? 'down' : 'up',\n\t\t\t\t\t\t\t\twhen: 'onEnterBack'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit('onEnterBack', element)\n\t\t\t\t},\n\t\t\t\tonLeaveBack: ({ direction }) => {\n\t\t\t\t\telement.classList.remove(this.classDefaults.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.remove(this.classDefaults.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tif (customEventName) {\n\t\t\t\t\t\t// Trigger custom event when the element enters the viewport\n\t\t\t\t\t\twindow.dispatchEvent(new CustomEvent(customEventName, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\ttarget: element,\n\t\t\t\t\t\t\t\tdirection: direction === 1 ? 'down' : 'up',\n\t\t\t\t\t\t\t\twhen: 'onLeaveBack'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit('onLeaveBack', element)\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\t// Get the sticky properties for ScrollTrigger animation\n\tgetStickyProperties(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn { pin: true, pinSpacing: false }\n\t\t} else {\n\t\t\treturn { pin: false, pinSpacing: true }\n\t\t}\n\t}\n\n\t// Check if an element has all the specified attributes\n\thasAttributes(element, attrs) {\n\t\treturn attrs.every((attr) => element.hasAttribute(attr))\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetAnimateFrom(element) {\n\t\treturn element.hasAttribute('data-onscroll-from') ? JSON.parse(element.dataset.onscrollFrom) : []\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetAnimateTo(element) {\n\t\treturn element.hasAttribute('data-onscroll-to') ? JSON.parse(element.dataset.onscrollTo) : []\n\t}\n\n\t// Get the offset value\n\tgetOffset(element) {\n\t\treturn element.hasAttribute('data-onscroll-offset') ? parseInt(element.dataset.onscrollOffset) : null\n\t}\n\n\t// Get the scroll direction\n\tgetDirection(element) {\n\t\treturn element.dataset.onscrollDirection\n\t}\n\n\t// Get the 'x' value for ScrollTrigger animation\n\tgetX(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn null\n\t\t}\n\t\tif (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the 'y' value for ScrollTrigger animation\n\tgetY(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn null\n\t\t}\n\t\tif (\n\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the offset and distance values\n\tgetOffsetAndDistance(element) {\n\t\t// Check if the element has the data-onscroll-sticky attribute\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn { offset: null, distance: null }\n\t\t}\n\n\t\tlet offset = null\n\t\tlet distance = null\n\t\tconst triggerElement = this.getTrigger(element)\n\t\tconst triggerHeight = triggerElement.offsetHeight\n\n\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\n\t\t\t// If the offset value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (offsetValue.trim().endsWith('%')) {\n\t\t\t\tconst offsetPercentage = parseFloat(offsetValue) / 100\n\t\t\t\toffset = offsetPercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\toffset = parseFloat(offsetValue)\n\t\t\t}\n\n\t\t\t// If the distance value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (distanceValue.trim().endsWith('%')) {\n\t\t\t\tconst distancePercentage = parseFloat(distanceValue) / 100\n\t\t\t\tdistance = distancePercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\tdistance = parseFloat(distanceValue)\n\t\t\t}\n\t\t}\n\n\t\treturn { offset, distance }\n\t}\n\n\t// Get the distance or speed value for ScrollTrigger animation\n\tgetDistanceOrSpeed(element) {\n\t\tconst { distance } = this.getOffsetAndDistance(element)\n\t\tconst viewportHeight = window.innerHeight\n\t\tlet scrollSpeed = element.dataset.onscrollSpeed\n\t\tlet additionalDistance = 0\n\n\t\t// Check if there are two values\n\t\tif (scrollSpeed && scrollSpeed.includes(',')) {\n\t\t\tconst [speed, percentage] = scrollSpeed.split(',').map(parseFloat)\n\n\t\t\t// Update the scrollSpeed and calculate the additional distance\n\t\t\tscrollSpeed = speed\n\t\t\tadditionalDistance = (percentage / 100) * viewportHeight\n\n\t\t\t// If scrollSpeed is negative, subtract the additional distance\n\t\t\tif (scrollSpeed < 0) {\n\t\t\t\tadditionalDistance *= -1\n\t\t\t}\n\t\t} else {\n\t\t\tscrollSpeed = parseFloat(scrollSpeed || '0')\n\t\t}\n\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto'])) {\n\t\t\tconst triggerElement = this.getTrigger(element)\n\t\t\tconst autoDistance = Math.abs(triggerElement.offsetHeight - element.offsetHeight)\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -autoDistance : autoDistance\n\t\t} else if (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\tconst elementHeight = element.offsetHeight\n\t\t\tconst scrollDistance = scrollSpeed * elementHeight + additionalDistance\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -scrollDistance : scrollDistance\n\t\t} else if (distance !== null) {\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -distance : distance\n\t\t}\n\t}\n\n\t// Get the delay value which controls the scrub setting\n\tgetScrub(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-delay'])) {\n\t\t\treturn parseInt(element.dataset.onscrollDelay)\n\t\t} else {\n\t\t\treturn true // Default scrub value if no 'data-onscroll-delay' attribute is present\n\t\t}\n\t}\n\n\t// Get the start value for ScrollTrigger animation\n\tgetStart(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\tlet stickyOffset = 0\n\n\t\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\t\tstickyOffset = parseFloat(offsetValue)\n\t\t\t}\n\n\t\t\treturn (element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top top') + '+=' + stickyOffset\n\t\t}\n\t\treturn element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top bottom'\n\t}\n\n\t// Get the end value for ScrollTrigger animation\n\tgetEnd(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\tconst trigger = this.getTrigger(element)\n\t\t\tlet stickyOffset = 0\n\n\t\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\t\tstickyOffset = parseFloat(distanceValue)\n\t\t\t}\n\n\t\t\tconst stickyDistance = trigger.clientHeight - element.clientHeight - stickyOffset\n\n\t\t\treturn '+=' + stickyDistance\n\t\t} else if (this.hasAttributes(element, ['data-onscroll-speed']) && !element.hasAttribute('data-onscroll-end')) {\n\t\t\tconst scrollDistance = this.getDistanceOrSpeed(element)\n\t\t\tconst { distance } = this.getOffsetAndDistance(element)\n\n\t\t\treturn `bottom${scrollDistance >= 0 ? '+=' : '-='}${Math.abs(scrollDistance)} top`\n\t\t} else {\n\t\t\treturn element.dataset.onscrollEnd ? element.dataset.onscrollEnd : 'bottom top'\n\t\t}\n\t}\n\n\t// Enable debug mode for logging\n\tdebugMode(element, index) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-debug'])) {\n\t\t\tconst { offset, distance } = this.getOffsetAndDistance(element)\n\t\t\tlet speedMultiplier\n\t\t\tlet speedViewportPercentage\n\t\t\tif (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\t\t;[speedMultiplier, speedViewportPercentage] = element.dataset.onscrollSpeed.split(',')\n\t\t\t}\n\t\t\tconsole.group(`OnscrollDetection() debug instance (#${index + 1})`)\n\t\t\tconsole.log({\n\t\t\t\telement: element,\n\t\t\t\ttrigger: this.getTrigger(element),\n\t\t\t\ttriggerStart: this.getStart(element),\n\t\t\t\ttriggerEnd: this.getEnd(element),\n\t\t\t\tauto: this.hasAttributes(element, ['data-onscroll-auto']),\n\t\t\t\toffsetBefore: offset,\n\t\t\t\toffsetAfter: this.getDistanceOrSpeed(element),\n\t\t\t\tdelay: this.getScrub(element),\n\t\t\t\tscreen: this.getScreen(element),\n\t\t\t\tspeed: this.hasAttributes(element, ['data-onscroll-speed'])\n\t\t\t\t\t? parseFloat(\n\t\t\t\t\t\t\tspeedMultiplier * element.clientHeight +\n\t\t\t\t\t\t\t\t(speedViewportPercentage / 100) * window.innerHeight\n\t\t\t\t\t  ) +\n\t\t\t\t\t  ' (' +\n\t\t\t\t\t  parseFloat(speedMultiplier) +\n\t\t\t\t\t  'x element height + ' +\n\t\t\t\t\t  parseFloat(speedViewportPercentage) +\n\t\t\t\t\t  '% of the viewport height)'\n\t\t\t\t\t: null,\n\t\t\t\tdirection: this.hasAttributes(element, ['data-onscroll-direction'])\n\t\t\t\t\t? element.dataset.onscrollDirection\n\t\t\t\t\t: 'y',\n\t\t\t\treverse: this.hasAttributes(element, ['data-onscroll-reverse']),\n\t\t\t\tsticky: this.hasAttributes(element, ['data-onscroll-sticky']) ? true : false,\n\t\t\t\tanimateFrom: this.getAnimateFrom(element),\n\t\t\t\tanimateTo: this.getAnimateTo(element),\n\t\t\t})\n\t\t\tconsole.groupEnd()\n\t\t}\n\t}\n\n\t// Fetch a trigger\n\tfetch(elementOrIndex) {\n\t\tif (typeof elementOrIndex === 'number') {\n\t\t\t// Treat argument as an index\n\t\t\tconst keys = Array.from(this.triggers.keys())\n\t\t\treturn keys[elementOrIndex]\n\t\t} else {\n\t\t\t// Assume argument is a DOM element\n\t\t\tlet trigger = null\n\t\t\tthis.triggers.forEach((value, key) => {\n\t\t\t\tif (value.element === elementOrIndex) {\n\t\t\t\t\ttrigger = key\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn trigger\n\t\t}\n\t}\n\n\t// Refresh ScrollTrigger instances\n\trefresh() {\n\t\tScrollTrigger.refresh()\n\n\t\t// Emit event after refresh is done\n\t\tthis.emit('refresh')\n\t}\n\n\t// Restart the animations and reinitialize the ScrollTrigger instances\n\trestart() {\n\t\t// Stop the current animations and remove ScrollTriggers\n\t\tthis.stop()\n\n\t\t// Kill all existing ScrollTrigger instances\n\t\tScrollTrigger.getAll().forEach((trigger) => trigger.kill())\n\n\t\t// Refresh ScrollTrigger\n\t\tScrollTrigger.refresh()\n\n\t\t// Reapply animations and initialize ScrollTrigger\n\t\tthis.init()\n\n\t\t// Emit event after restart is done\n\t\tthis.emit('restart')\n\t}\n\n\t// Stop animations and ScrollTriggers\n\tstop(target = null) {\n\t\tif (target) {\n\t\t\t// Stop animation and remove the ScrollTrigger for a specific target\n\t\t\tconst animationData = this.triggers.get(target)\n\t\t\tif (animationData) {\n\t\t\t\tanimationData.gsapAnimation.kill()\n\t\t\t\tthis.triggers.delete(target)\n\t\t\t}\n\t\t} else {\n\t\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\t\tthis.triggers.forEach(({ gsapAnimation }) => {\n\t\t\t\tgsapAnimation.kill()\n\t\t\t})\n\t\t\tthis.triggers.clear()\n\t\t}\n\n\t\t// Emit event after stop is done\n\t\tthis.emit('stop', target)\n\t}\n\n\t// Update animation for a specific target with new fromProperties and toProperties\n\tupdate(target, fromProperties, toProperties) {\n\t\tconst animationData = this.triggers.get(target)\n\n\t\tif (animationData) {\n\t\t\t// Stop the existing animation\n\t\t\tanimationData.gsapAnimation.kill()\n\n\t\t\t// Reinitialize the animation with updated properties\n\t\t\tconst gsapAnimation = gsap.fromTo(animationData.element, fromProperties, toProperties)\n\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t...animationData,\n\t\t\t\tfromProperties,\n\t\t\t\ttoProperties,\n\t\t\t\tgsapAnimation,\n\t\t\t})\n\t\t}\n\t}\n\n\t// Destroy the OnscrollDetection instance\n\tdestroy() {\n\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\tthis.stop()\n\t\tthis.triggers = null\n\t}\n}\n"],"names":["OnscrollDetection","options","this","elements","screen","triggers","Map","classDefaults","_extends","scrollingClass","scrolledClass","stickyClass","stuckClass","eventHandlers","init","_proto","prototype","_this","gsap","utils","toArray","forEach","element","index","trigger","getTrigger","getScreen","matchMedia","fromProperties","getFromProperties","toProperties","getToProperties","add","gsapAnimation","fromTo","set","scrollTrigger","debugMode","on","event","handler","push","emit","_arguments","arguments","apply","slice","call","hasAttributes","hasAttribute","parentElement","document","querySelector","dataset","onscrollTrigger","console","error","onscrollScreen","animateFrom","getAnimateFrom","offset","getOffsetAndDistance","bottom","top","x","getDirection","y","_this2","animateTo","getAnimateTo","stickyProperties","getStickyProperties","isSticky","customEventName","getAttribute","getX","getY","ease","start","getStart","end","getEnd","invalidateOnRefresh","pin","pinSpacing","scrub","getScrub","markers","onEnter","_ref","direction","classList","window","dispatchEvent","CustomEvent","detail","target","when","onLeave","_ref2","remove","onEnterBack","_ref3","onLeaveBack","_ref4","attrs","every","attr","JSON","parse","onscrollFrom","onscrollTo","getOffset","parseInt","onscrollOffset","onscrollDirection","getDistanceOrSpeed","distance","triggerHeight","offsetHeight","_element$dataset$onsc","split","offsetValue","distanceValue","trim","endsWith","parseFloat","viewportHeight","innerHeight","scrollSpeed","onscrollSpeed","additionalDistance","includes","_scrollSpeed$split$ma","map","triggerElement","autoDistance","Math","abs","scrollDistance","onscrollDelay","stickyOffset","_element$dataset$onsc2","onscrollStart","_element$dataset$onsc3","clientHeight","onscrollEnd","speedMultiplier","speedViewportPercentage","_element$dataset$onsc4","group","log","triggerStart","triggerEnd","auto","offsetBefore","offsetAfter","delay","speed","reverse","sticky","groupEnd","fetch","elementOrIndex","Array","from","keys","value","key","refresh","ScrollTrigger","restart","stop","getAll","kill","animationData","get","_ref5","clear","update","destroy"],"mappings":"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"}