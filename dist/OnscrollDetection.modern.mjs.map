{"version":3,"file":"OnscrollDetection.modern.mjs","sources":["../src/index.js"],"sourcesContent":["export default class OnscrollDetection {\n\tconstructor(options = {}) {\n\t\t// Initialise class properties with default values or provided options\n\t\tthis.elements = options.elements || '[data-onscroll]'\n\t\tthis.screen = options.screen || '(min-width: 1025px)'\n\t\tthis.triggers = new Map()\n\n\t\t// Set class names to defaults or provided options\n\t\tthis.scrollingClass = options.scrollingClass || 'is-scrolling'\n\t\tthis.scrolledClass = options.scrolledClass || 'has-scrolled'\n\t\tthis.stickyClass = options.stickyClass || 'is-sticky'\n\t\tthis.stuckClass = options.stuckClass || 'has-stuck'\n\n\t\t// Initialise event handlers\n\t\tthis.eventHandlers = {}\n\n\t\t// Set autoStart to true by default, or use provided value\n\t\tthis.autoStart = options.autoStart !== undefined ? options.autoStart : true\n\n\t\t// Initialise the class\n\t\tif (this.autoStart) {\n\t\t\tthis.init()\n\t\t}\n\t}\n\n\t// Initialisation function\n\tinit() {\n\t\t// Convert elements to an array and loop through each\n\t\tgsap.utils.toArray(this.elements).forEach((element, index) => {\n\t\t\t// Get the trigger element\n\t\t\tconst trigger = this.getTrigger(element)\n\n\t\t\t// Get the screen media query\n\t\t\tconst screen = this.getScreen(element)\n\n\t\t\t// Create a matchMedia instance\n\t\t\tconst matchMedia = gsap.matchMedia()\n\n\t\t\t// Get the animation properties for 'from' state\n\t\t\tconst fromProperties = this.getFromProperties(element, index)\n\n\t\t\t// Get the animation properties for 'to' state\n\t\t\tconst toProperties = this.getToProperties(element, index, trigger)\n\n\t\t\t// Add the animation to the matchMedia instance and store the ScrollTrigger instance\n\t\t\tconst animation = matchMedia.add(screen, () => {\n\t\t\t\tconst gsapAnimation = gsap.fromTo(element, fromProperties, toProperties)\n\n\t\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t\telement,\n\t\t\t\t\tfromProperties,\n\t\t\t\t\ttoProperties,\n\t\t\t\t\tgsapAnimation,\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// Enable debug mode for logging\n\t\t\tthis.debugMode(element, index)\n\t\t})\n\t}\n\n\t// Function to load and initialize the class\n\tstart() {\n\t\t// Initialize the class\n\t\tthis.init()\n\t}\n\n\t// Helper methods\n\ton(event, handler) {\n\t\tif (!this.eventHandlers[event]) {\n\t\t\tthis.eventHandlers[event] = []\n\t\t}\n\t\tthis.eventHandlers[event].push(handler)\n\t}\n\n\temit(event, ...args) {\n\t\tif (this.eventHandlers[event]) {\n\t\t\tthis.eventHandlers[event].forEach((handler) => handler(...args))\n\t\t}\n\t}\n\n\t// Get the trigger element for ScrollTrigger\n\tgetTrigger(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto']) && !element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-auto is present and data-onscroll-trigger is not, use the parent element as the trigger\n\t\t\treturn element.parentElement\n\t\t} else if (element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-trigger is present, try to find the DOM element specified by the attribute\n\t\t\tlet triggerElement = document.querySelector(element.dataset.onscrollTrigger)\n\t\t\tif (triggerElement) {\n\t\t\t\treturn triggerElement\n\t\t\t} else {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`Element specified by data-onscroll-trigger not found: ${element.dataset.onscrollTrigger}`\n\t\t\t\t)\n\t\t\t\treturn element\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise, use the element itself as the trigger\n\t\t\treturn element\n\t\t}\n\t}\n\n\t// Get the screen media query\n\tgetScreen(element) {\n\t\treturn element.hasAttribute('data-onscroll-screen') ? element.dataset.onscrollScreen : this.screen\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetFromProperties(element, index) {\n\t\tconst animateFrom = this.getAnimateFrom(element)\n\t\tconst { offset } = this.getOffsetAndDistance(element)\n\n\t\treturn {\n\t\t\t...animateFrom,\n\t\t\tbottom: this.hasAttributes(element, ['data-onscroll-auto', 'data-onscroll-reverse']) ? 'auto' : null,\n\t\t\ttop:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-auto']) &&\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-reverse'])\n\t\t\t\t\t? 'auto'\n\t\t\t\t\t: null,\n\t\t\tx:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t\ty:\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t}\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetToProperties(element, index, trigger) {\n\t\tconst animateTo = this.getAnimateTo(element)\n\t\tconst stickyProperties = this.getStickyProperties(element)\n\t\tconst isSticky = this.hasAttributes(element, ['data-onscroll-sticky'])\n\t\tconst customEventName = element.getAttribute('data-onscroll-call')\n\n\t\t// Helper function to dispatch the custom event\n\t\tconst dispatchCustomEvent = (when, direction) => {\n\t\t\tif (customEventName) {\n\t\t\t\twindow.dispatchEvent(\n\t\t\t\t\tnew CustomEvent(customEventName, {\n\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\ttarget: element,\n\t\t\t\t\t\t\tdirection: direction === 1 ? 'down' : 'up',\n\t\t\t\t\t\t\twhen,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t...animateTo,\n\t\t\tx: this.getX(element),\n\t\t\ty: this.getY(element),\n\t\t\tease: 'none',\n\t\t\tscrollTrigger: {\n\t\t\t\ttrigger: isSticky ? element : trigger,\n\t\t\t\tstart: this.getStart(element),\n\t\t\t\tend: this.getEnd(element),\n\t\t\t\tinvalidateOnRefresh: true,\n\t\t\t\tpin: stickyProperties.pin,\n\t\t\t\tpinSpacing: stickyProperties.pinSpacing,\n\t\t\t\tscrub: this.getScrub(element),\n\t\t\t\tmarkers: this.hasAttributes(element, ['data-onscroll-debug']),\n\t\t\t\tonEnter: ({ direction }) => {\n\t\t\t\t\telement.classList.add(this.scrollingClass, this.scrolledClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.add(this.stickyClass, this.stuckClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onEnter', direction)\n\t\t\t\t\tthis.emit('onEnter', element)\n\t\t\t\t},\n\t\t\t\tonLeave: ({ direction }) => {\n\t\t\t\t\telement.classList.remove(this.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.remove(this.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onLeave', direction)\n\t\t\t\t\tthis.emit('onLeave', element)\n\t\t\t\t},\n\t\t\t\tonEnterBack: ({ direction }) => {\n\t\t\t\t\telement.classList.add(this.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.add(this.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onEnterBack', direction)\n\t\t\t\t\tthis.emit('onEnterBack', element)\n\t\t\t\t},\n\t\t\t\tonLeaveBack: ({ direction }) => {\n\t\t\t\t\telement.classList.remove(this.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.remove(this.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onLeaveBack', direction)\n\t\t\t\t\tthis.emit('onLeaveBack', element)\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\t// Get the sticky properties for ScrollTrigger animation\n\tgetStickyProperties(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn { pin: true, pinSpacing: false }\n\t\t} else {\n\t\t\treturn { pin: false, pinSpacing: true }\n\t\t}\n\t}\n\n\t// Check if an element has all the specified attributes\n\thasAttributes(element, attrs) {\n\t\treturn attrs.every((attr) => element.hasAttribute(attr))\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetAnimateFrom(element) {\n\t\treturn element.hasAttribute('data-onscroll-from') ? JSON.parse(element.dataset.onscrollFrom) : []\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetAnimateTo(element) {\n\t\treturn element.hasAttribute('data-onscroll-to') ? JSON.parse(element.dataset.onscrollTo) : []\n\t}\n\n\t// Get the offset value\n\tgetOffset(element) {\n\t\treturn element.hasAttribute('data-onscroll-offset') ? parseInt(element.dataset.onscrollOffset) : null\n\t}\n\n\t// Get the scroll direction\n\tgetDirection(element) {\n\t\treturn element.dataset.onscrollDirection\n\t}\n\n\t// Get the 'x' value for ScrollTrigger animation\n\tgetX(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn null\n\t\t}\n\t\tif (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the 'y' value for ScrollTrigger animation\n\tgetY(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn null\n\t\t}\n\t\tif (\n\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the offset and distance values\n\tgetOffsetAndDistance(element) {\n\t\t// Check if the element has the data-onscroll-sticky attribute\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn { offset: null, distance: null }\n\t\t}\n\n\t\tlet offset = null\n\t\tlet distance = null\n\t\tconst triggerElement = this.getTrigger(element)\n\t\tconst triggerHeight = triggerElement.offsetHeight\n\n\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\n\t\t\t// If the offset value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (offsetValue.trim().endsWith('%')) {\n\t\t\t\tconst offsetPercentage = parseFloat(offsetValue) / 100\n\t\t\t\toffset = offsetPercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\toffset = parseFloat(offsetValue)\n\t\t\t}\n\n\t\t\t// If the distance value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (distanceValue.trim().endsWith('%')) {\n\t\t\t\tconst distancePercentage = parseFloat(distanceValue) / 100\n\t\t\t\tdistance = distancePercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\tdistance = parseFloat(distanceValue)\n\t\t\t}\n\t\t}\n\n\t\treturn { offset, distance }\n\t}\n\n\t// Get the distance or speed value for ScrollTrigger animation\n\tgetDistanceOrSpeed(element) {\n\t\tconst { distance } = this.getOffsetAndDistance(element)\n\t\tconst viewportHeight = window.innerHeight\n\t\tlet scrollSpeed = element.dataset.onscrollSpeed\n\t\tlet additionalDistance = 0\n\n\t\t// Check if there are two values\n\t\tif (scrollSpeed && scrollSpeed.includes(',')) {\n\t\t\tconst [speed, percentage] = scrollSpeed.split(',').map(parseFloat)\n\n\t\t\t// Update the scrollSpeed and calculate the additional distance\n\t\t\tscrollSpeed = speed\n\t\t\tadditionalDistance = (percentage / 100) * viewportHeight\n\n\t\t\t// If scrollSpeed is negative, subtract the additional distance\n\t\t\tif (scrollSpeed < 0) {\n\t\t\t\tadditionalDistance *= -1\n\t\t\t}\n\t\t} else {\n\t\t\tscrollSpeed = parseFloat(scrollSpeed || '0')\n\t\t}\n\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto'])) {\n\t\t\tconst triggerElement = this.getTrigger(element)\n\t\t\tconst autoDistance = Math.abs(triggerElement.offsetHeight - element.offsetHeight)\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -autoDistance : autoDistance\n\t\t} else if (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\tconst elementHeight = element.offsetHeight\n\t\t\tconst scrollDistance = scrollSpeed * elementHeight + additionalDistance\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -scrollDistance : scrollDistance\n\t\t} else if (distance !== null) {\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -distance : distance\n\t\t}\n\t}\n\n\t// Get the delay value which controls the scrub setting\n\tgetScrub(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-delay'])) {\n\t\t\treturn parseInt(element.dataset.onscrollDelay)\n\t\t} else {\n\t\t\treturn true // Default scrub value if no 'data-onscroll-delay' attribute is present\n\t\t}\n\t}\n\n\t// Get the start value for ScrollTrigger animation\n\tgetStart(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\tlet stickyOffset = 0\n\n\t\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\t\tstickyOffset = parseFloat(offsetValue)\n\t\t\t}\n\n\t\t\treturn (element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top top') + '+=' + stickyOffset\n\t\t}\n\t\treturn element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top bottom'\n\t}\n\n\t// Get the end value for ScrollTrigger animation\n\tgetEnd(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\tconst trigger = this.getTrigger(element)\n\t\t\tlet stickyOffset = 0\n\n\t\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\t\tstickyOffset = parseFloat(distanceValue)\n\t\t\t}\n\n\t\t\tconst stickyDistance = trigger.clientHeight - element.clientHeight - stickyOffset\n\n\t\t\treturn '+=' + stickyDistance\n\t\t} else if (this.hasAttributes(element, ['data-onscroll-speed']) && !element.hasAttribute('data-onscroll-end')) {\n\t\t\tconst scrollDistance = this.getDistanceOrSpeed(element)\n\t\t\tconst { distance } = this.getOffsetAndDistance(element)\n\n\t\t\treturn `bottom${scrollDistance >= 0 ? '+=' : '-='}${Math.abs(scrollDistance)} top`\n\t\t} else {\n\t\t\treturn element.dataset.onscrollEnd ? element.dataset.onscrollEnd : 'bottom top'\n\t\t}\n\t}\n\n\t// Enable debug mode for logging\n\tdebugMode(element, index) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-debug'])) {\n\t\t\tconst { offset, distance } = this.getOffsetAndDistance(element)\n\t\t\tlet speedMultiplier\n\t\t\tlet speedViewportPercentage\n\t\t\tif (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\t\t;[speedMultiplier, speedViewportPercentage] = element.dataset.onscrollSpeed.split(',')\n\t\t\t}\n\t\t\tconsole.group(`OnscrollDetection() debug instance (#${index + 1})`)\n\t\t\tconsole.log({\n\t\t\t\telement: element,\n\t\t\t\ttrigger: this.getTrigger(element),\n\t\t\t\ttriggerStart: this.getStart(element),\n\t\t\t\ttriggerEnd: this.getEnd(element),\n\t\t\t\tauto: this.hasAttributes(element, ['data-onscroll-auto']),\n\t\t\t\toffsetBefore: offset,\n\t\t\t\toffsetAfter: this.getDistanceOrSpeed(element),\n\t\t\t\tdelay: this.getScrub(element),\n\t\t\t\tscreen: this.getScreen(element),\n\t\t\t\tspeed: this.hasAttributes(element, ['data-onscroll-speed'])\n\t\t\t\t\t? parseFloat(\n\t\t\t\t\t\t\tspeedMultiplier * element.clientHeight +\n\t\t\t\t\t\t\t\t(speedViewportPercentage / 100) * window.innerHeight\n\t\t\t\t\t  ) +\n\t\t\t\t\t  ' (' +\n\t\t\t\t\t  parseFloat(speedMultiplier) +\n\t\t\t\t\t  'x element height + ' +\n\t\t\t\t\t  parseFloat(speedViewportPercentage) +\n\t\t\t\t\t  '% of the viewport height)'\n\t\t\t\t\t: null,\n\t\t\t\tdirection: this.hasAttributes(element, ['data-onscroll-direction'])\n\t\t\t\t\t? element.dataset.onscrollDirection\n\t\t\t\t\t: 'y',\n\t\t\t\treverse: this.hasAttributes(element, ['data-onscroll-reverse']),\n\t\t\t\tsticky: this.hasAttributes(element, ['data-onscroll-sticky']) ? true : false,\n\t\t\t\tanimateFrom: this.getAnimateFrom(element),\n\t\t\t\tanimateTo: this.getAnimateTo(element),\n\t\t\t\tcustomEvent: this.hasAttributes(element, ['data-onscroll-call'])\n\t\t\t\t\t? element.getAttribute('data-onscroll-call')\n\t\t\t\t\t: null,\n\t\t\t})\n\t\t\tconsole.groupEnd()\n\t\t}\n\t}\n\n\t// Fetch a trigger\n\tfetch(elementOrIndex) {\n\t\tif (typeof elementOrIndex === 'number') {\n\t\t\t// Treat argument as an index\n\t\t\tconst keys = Array.from(this.triggers.keys())\n\t\t\treturn keys[elementOrIndex]\n\t\t} else {\n\t\t\t// Assume argument is a DOM element\n\t\t\tlet trigger = null\n\t\t\tthis.triggers.forEach((value, key) => {\n\t\t\t\tif (value.element === elementOrIndex) {\n\t\t\t\t\ttrigger = key\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn trigger\n\t\t}\n\t}\n\n\t// Refresh ScrollTrigger instances\n\trefresh() {\n\t\tScrollTrigger.refresh()\n\n\t\t// Emit event after refresh is done\n\t\tthis.emit('refresh')\n\t}\n\n\t// Restart the animations and reinitialize the ScrollTrigger instances\n\trestart() {\n\t\t// Stop the current animations and remove ScrollTriggers\n\t\tthis.stop()\n\n\t\t// Kill all existing ScrollTrigger instances\n\t\tScrollTrigger.getAll().forEach((trigger) => trigger.kill())\n\n\t\t// Refresh ScrollTrigger\n\t\tScrollTrigger.refresh()\n\n\t\t// Reapply animations and initialize ScrollTrigger\n\t\tthis.init()\n\n\t\t// Emit event after restart is done\n\t\tthis.emit('restart')\n\t}\n\n\t// Stop animations and ScrollTriggers\n\tstop(target = null) {\n\t\tif (target) {\n\t\t\t// Stop animation and remove the ScrollTrigger for a specific target\n\t\t\tconst animationData = this.triggers.get(target)\n\t\t\tif (animationData) {\n\t\t\t\tanimationData.gsapAnimation.kill()\n\t\t\t\tthis.triggers.delete(target)\n\t\t\t}\n\t\t} else {\n\t\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\t\tthis.triggers.forEach(({ gsapAnimation }) => {\n\t\t\t\tgsapAnimation.kill()\n\t\t\t})\n\t\t\tthis.triggers.clear()\n\t\t}\n\n\t\t// Emit event after stop is done\n\t\tthis.emit('stop', target)\n\t}\n\n\t// Update animation for a specific target with new fromProperties and toProperties\n\tupdate(target, fromProperties, toProperties) {\n\t\tconst animationData = this.triggers.get(target)\n\n\t\tif (animationData) {\n\t\t\t// Stop the existing animation\n\t\t\tanimationData.gsapAnimation.kill()\n\n\t\t\t// Reinitialize the animation with updated properties\n\t\t\tconst gsapAnimation = gsap.fromTo(animationData.element, fromProperties, toProperties)\n\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t...animationData,\n\t\t\t\tfromProperties,\n\t\t\t\ttoProperties,\n\t\t\t\tgsapAnimation,\n\t\t\t})\n\t\t}\n\t}\n\n\t// Destroy the OnscrollDetection instance\n\tdestroy() {\n\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\tthis.stop()\n\t\tthis.triggers = null\n\t}\n}\n"],"names":["OnscrollDetection","constructor","options","this","elements","screen","triggers","Map","scrollingClass","scrolledClass","stickyClass","stuckClass","eventHandlers","autoStart","undefined","init","gsap","utils","toArray","forEach","element","index","trigger","getTrigger","getScreen","matchMedia","fromProperties","getFromProperties","toProperties","getToProperties","add","gsapAnimation","fromTo","set","scrollTrigger","debugMode","start","on","event","handler","push","emit","args","hasAttributes","hasAttribute","parentElement","document","querySelector","dataset","onscrollTrigger","console","error","onscrollScreen","animateFrom","getAnimateFrom","offset","getOffsetAndDistance","_extends","bottom","top","x","getDirection","y","animateTo","getAnimateTo","stickyProperties","getStickyProperties","isSticky","customEventName","getAttribute","dispatchCustomEvent","when","direction","window","dispatchEvent","CustomEvent","detail","target","getX","getY","ease","getStart","end","getEnd","invalidateOnRefresh","pin","pinSpacing","scrub","getScrub","markers","onEnter","classList","onLeave","remove","onEnterBack","onLeaveBack","attrs","every","attr","JSON","parse","onscrollFrom","onscrollTo","getOffset","parseInt","onscrollOffset","onscrollDirection","getDistanceOrSpeed","distance","triggerHeight","offsetHeight","offsetValue","distanceValue","split","trim","endsWith","parseFloat","viewportHeight","innerHeight","scrollSpeed","onscrollSpeed","additionalDistance","includes","speed","percentage","map","triggerElement","autoDistance","Math","abs","scrollDistance","onscrollDelay","stickyOffset","onscrollStart","clientHeight","onscrollEnd","speedMultiplier","speedViewportPercentage","group","log","triggerStart","triggerEnd","auto","offsetBefore","offsetAfter","delay","reverse","sticky","customEvent","groupEnd","fetch","elementOrIndex","Array","from","keys","value","key","refresh","ScrollTrigger","restart","stop","getAll","kill","animationData","get","delete","clear","update","destroy"],"mappings":"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"}