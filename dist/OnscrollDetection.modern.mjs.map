{"version":3,"file":"OnscrollDetection.modern.mjs","sources":["../src/index.js"],"sourcesContent":["export default class OnscrollDetection {\n\tconstructor(options = {}) {\n\t\t// Initialise class properties with default values or provided options\n\t\tthis.elements = options.elements || '[data-onscroll]'\n\t\tthis.screen = options.screen || '(min-width: 768px)'\n\t\tthis.triggers = new Map()\n\n\t\t// Initialise the class\n\t\tthis.init()\n\t}\n\n\t// Initialisation function\n\tinit() {\n\t\t// Convert elements to an array and loop through each\n\t\tgsap.utils.toArray(this.elements).forEach((element, index) => {\n\t\t\t// Get the trigger element\n\t\t\tconst trigger = this.getTrigger(element)\n\n\t\t\t// Get the screen media query\n\t\t\tconst screen = this.getScreen(element)\n\n\t\t\t// Create a matchMedia instance\n\t\t\tconst matchMedia = gsap.matchMedia()\n\n\t\t\t// Get the animation properties for 'from' state\n\t\t\tconst fromProperties = this.getFromProperties(element, index)\n\n\t\t\t// Get the animation properties for 'to' state\n\t\t\tconst toProperties = this.getToProperties(element, index, trigger)\n\n\t\t\t// Add the animation to the matchMedia instance and store the ScrollTrigger instance\n\t\t\tconst animation = matchMedia.add(screen, () => {\n\t\t\t\tconst gsapAnimation = gsap.fromTo(element, fromProperties, toProperties)\n\t\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t\telement,\n\t\t\t\t\tfromProperties,\n\t\t\t\t\ttoProperties,\n\t\t\t\t\tgsapAnimation,\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// Enable debug mode for logging\n\t\t\tthis.debugMode(element, index)\n\t\t})\n\t}\n\n\t// Helper methods\n\n\t// Get the trigger element for ScrollTrigger\n\tgetTrigger(element) {\n\t    if (this.hasAttributes(element, ['data-onscroll-auto']) && !element.hasAttribute('data-onscroll-trigger')) {\n\t        // If data-onscroll-auto is present and data-onscroll-trigger is not, use the parent element as the trigger\n\t        return element.parentElement;\n\t    } else if (element.hasAttribute('data-onscroll-trigger')) {\n\t        // If data-onscroll-trigger is present, use the parent element as the trigger\n\t        return element.parentElement;\n\t    } else {\n\t        // Otherwise, use the element itself as the trigger\n\t        return element;\n\t    }\n\t}\n\n\t// Get the screen media query\n\tgetScreen(element) {\n\t\treturn element.hasAttribute('data-onscroll-screen') ? element.dataset.onscrollScreen : this.screen\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetFromProperties(element, index) {\n\t\tconst animateFrom = this.getAnimateFrom(element);\n\t\tconst { offset } = this.getOffsetAndDistance(element);\n\n\t\treturn {\n\t\t\t...animateFrom,\n\t\t\tbottom: this.hasAttributes(element, ['data-onscroll-auto', 'data-onscroll-reverse']) ? 'auto' : null,\n\t\t\ttop:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-auto']) &&\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-reverse'])\n\t\t\t\t\t? 'auto'\n\t\t\t\t\t: null,\n\t\t\tx:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t\ty:\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t}\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetToProperties(element, index, trigger) {\n\t\tconst animateTo = this.getAnimateTo(element);\n\t\tconst { offset } = this.getOffsetAndDistance(element);\n\n\t    return {\n\t        ...animateTo,\n\t        x: this.getX(element),\n\t        y: this.getY(element),\n\t        ease: 'none',\n\t        scrollTrigger: {\n\t            trigger: trigger,\n\t            start: this.getStart(element),\n\t            end: this.getEnd(element),\n\t            invalidateOnRefresh: true,\n\t            scrub: this.getScrub(element),\n\t            markers: this.hasAttributes(element, ['data-onscroll-debug']),\n\t        },\n\t    }\n\t}\n\n\t// Check if an element has all the specified attributes\n\thasAttributes(element, attrs) {\n\t\treturn attrs.every((attr) => element.hasAttribute(attr))\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetAnimateFrom(element) {\n\t\treturn element.hasAttribute('data-onscroll-from') ? JSON.parse(element.dataset.onscrollFrom) : []\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetAnimateTo(element) {\n\t\treturn element.hasAttribute('data-onscroll-to') ? JSON.parse(element.dataset.onscrollTo) : []\n\t}\n\n\t// Get the offset value\n\tgetOffset(element) {\n\t\treturn element.hasAttribute('data-onscroll-offset') ? parseInt(element.dataset.onscrollOffset) : null\n\t}\n\n\t// Get the scroll direction\n\tgetDirection(element) {\n\t\treturn element.dataset.onscrollDirection\n\t}\n\n\t// Get the 'x' value for ScrollTrigger animation\n\tgetX(element) {\n\t\tif (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the 'y' value for ScrollTrigger animation\n\tgetY(element) {\n\t\tif (\n\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the offset and distance values\n\tgetOffsetAndDistance(element) {\n\t    let offset = null;\n\t    let distance = null;\n\t    const triggerElement = this.getTrigger(element);\n\t    const triggerHeight = triggerElement.offsetHeight;\n\n\t    if (element.hasAttribute('data-onscroll-offset')) {\n\t        const [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',');\n\n\t        // If the offset value ends with a '%', calculate it as a percentage of the trigger height\n\t        if (offsetValue.trim().endsWith('%')) {\n\t            const offsetPercentage = parseFloat(offsetValue) / 100;\n\t            offset = offsetPercentage * triggerHeight;\n\t        } else {\n\t            offset = parseFloat(offsetValue);\n\t        }\n\n\t        // If the distance value ends with a '%', calculate it as a percentage of the trigger height\n\t        if (distanceValue.trim().endsWith('%')) {\n\t            const distancePercentage = parseFloat(distanceValue) / 100;\n\t            distance = distancePercentage * triggerHeight;\n\t        } else {\n\t            distance = parseFloat(distanceValue);\n\t        }\n\t    }\n\n\t    return { offset, distance };\n\t}\n\n\t// Get the distance or speed value for ScrollTrigger animation\n\tgetDistanceOrSpeed(element) {\n\t    const { distance } = this.getOffsetAndDistance(element);\n\t    const viewportHeight = window.innerHeight;\n\t    let scrollSpeed = element.dataset.onscrollSpeed;\n\t    let additionalDistance = 0;\n\n\t    // Check if there are two values\n\t    if (scrollSpeed && scrollSpeed.includes(',')) {\n\t        const [speed, percentage] = scrollSpeed.split(',').map(parseFloat);\n\n\t        // Update the scrollSpeed and calculate the additional distance\n\t        scrollSpeed = speed;\n\t        additionalDistance = (percentage / 100) * viewportHeight;\n\n\t        // If scrollSpeed is negative, subtract the additional distance\n\t        if (scrollSpeed < 0) {\n\t            additionalDistance *= -1;\n\t        }\n\t    } else {\n\t        scrollSpeed = parseFloat(scrollSpeed || \"0\");\n\t    }\n\n\t    if (this.hasAttributes(element, ['data-onscroll-auto'])) {\n\t        const triggerElement = this.getTrigger(element);\n\t        const autoDistance = Math.abs(triggerElement.offsetHeight - element.offsetHeight);\n\t        return this.hasAttributes(element, ['data-onscroll-reverse']) ? -autoDistance : autoDistance;\n\t    } else if (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t        const elementHeight = element.offsetHeight;\n\t        const scrollDistance = scrollSpeed * elementHeight + additionalDistance;\n\t        return this.hasAttributes(element, ['data-onscroll-reverse']) ? -scrollDistance : scrollDistance;\n\t    } else if (distance !== null) {\n\t        return this.hasAttributes(element, ['data-onscroll-reverse']) ? -distance : distance;\n\t    }\n\t}\n\n\t// Get the delay value which controls the scrub setting\n\tgetScrub(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-delay'])) {\n\t\t\treturn parseInt(element.dataset.onscrollDelay);\n\t\t} else {\n\t\t\treturn true;  // Default scrub value if no 'data-onscroll-delay' attribute is present\n\t\t}\n\t}\n\n\t// Get the start value for ScrollTrigger animation\n\tgetStart(element) {\n\t\treturn element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top bottom'\n\t}\n\n\t// Get the end value for ScrollTrigger animation\n\tgetEnd(element) {\n\n\t\tif (this.hasAttributes(element, ['data-onscroll-speed']) && !element.hasAttribute('data-onscroll-end')) {\n\t\t    const scrollDistance = this.getDistanceOrSpeed(element);\n\t\t    const { distance } = this.getOffsetAndDistance(element);\n\t\t    \n\t\t    return `bottom${scrollDistance >= 0 ? '+=' : '-='}${Math.abs(scrollDistance)} top`;\n\n\t\t} else {\n\t\t\treturn element.dataset.onscrollEnd ? element.dataset.onscrollEnd : 'bottom top';\n\t\t}\n\n\t}\n\n\t// Enable debug mode for logging\n\tdebugMode(element, index) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-debug'])) {\n        \tconst { offset, distance } = this.getOffsetAndDistance(element);\n\t\t\tconsole.group(`OnscrollDetection() debug instance (#${index + 1})`)\n\t\t\tconsole.log({\n\t\t\t\telement: element,\n\t\t\t\ttrigger: this.getTrigger(element),\n\t\t\t\ttriggerStart: this.getStart(element),\n\t\t\t\ttriggerEnd: this.getEnd(element),\n\t\t\t\tauto: this.hasAttributes(element, ['data-onscroll-auto']),\n\t\t\t\toffsetBefore: offset,\n\t            offsetAfter: this.getDistanceOrSpeed(element),\n\t            delay: this.getScrub(element),\n\t            screen: this.getScreen(element),\n\t\t\t\tspeed: this.hasAttributes(element, ['data-onscroll-speed'])\n\t\t\t\t\t? element.dataset.onscrollSpeed +\n\t\t\t\t\t  ' calculated at ' +\n\t\t\t\t\t  (1 - parseFloat(element.dataset.onscrollSpeed)) *\n\t\t\t\t\t\t\t(ScrollTrigger.maxScroll(window) - (this.scrollTrigger ? this.scrollTrigger.start : 0))\n\t\t\t\t\t: null,\n\t\t\t\tdirection: this.hasAttributes(element, ['data-onscroll-direction'])\n\t\t\t\t\t? element.dataset.onscrollDirection\n\t\t\t\t\t: 'y',\n\t\t\t\treverse: this.hasAttributes(element, ['data-onscroll-reverse']),\n\t\t\t\tanimateFrom: this.getAnimateFrom(element),\n\t\t\t\tanimateTo: this.getAnimateTo(element),\n\t\t\t})\n\t\t\tconsole.groupEnd()\n\t\t}\n\t}\n\n\t// Refresh ScrollTrigger instances\n\trefresh() {\n\t\tScrollTrigger.refresh()\n\t}\n\n\t// Restart the animations and reinitialize the ScrollTrigger instances\n\trestart() {\n\t\t// Stop the current animations and remove ScrollTriggers\n\t\tthis.stop()\n\n\t\t// Kill all existing ScrollTrigger instances\n\t\tScrollTrigger.getAll().forEach((trigger) => trigger.kill())\n\n\t\t// Refresh ScrollTrigger\n\t\tScrollTrigger.refresh()\n\n\t\t// Reapply animations and initialize ScrollTrigger\n\t\tthis.init()\n\t}\n\n\t// Stop animations and ScrollTriggers\n\tstop(target = null) {\n\t\tif (target) {\n\t\t\t// Stop animation and remove the ScrollTrigger for a specific target\n\t\t\tconst animationData = this.triggers.get(target)\n\t\t\tif (animationData) {\n\t\t\t\tanimationData.gsapAnimation.kill()\n\t\t\t\tthis.triggers.delete(target)\n\t\t\t}\n\t\t} else {\n\t\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\t\tthis.triggers.forEach(({ gsapAnimation }) => {\n\t\t\t\tgsapAnimation.kill()\n\t\t\t})\n\t\t\tthis.triggers.clear()\n\t\t}\n\t}\n\n\t// Update animation for a specific target with new fromProperties and toProperties\n\tupdate(target, fromProperties, toProperties) {\n\t\tconst animationData = this.triggers.get(target)\n\n\t\tif (animationData) {\n\t\t\t// Stop the existing animation\n\t\t\tanimationData.gsapAnimation.kill()\n\n\t\t\t// Reinitialize the animation with updated properties\n\t\t\tconst gsapAnimation = gsap.fromTo(animationData.element, fromProperties, toProperties)\n\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t...animationData,\n\t\t\t\tfromProperties,\n\t\t\t\ttoProperties,\n\t\t\t\tgsapAnimation,\n\t\t\t})\n\t\t}\n\t}\n\n\t// Destroy the OnscrollDetection instance\n\tdestroy() {\n\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\tthis.stop()\n\t\tthis.triggers = null\n\t}\n}"],"names":["OnscrollDetection","constructor","options","this","elements","screen","triggers","Map","init","gsap","utils","toArray","forEach","element","index","trigger","getTrigger","getScreen","matchMedia","fromProperties","getFromProperties","toProperties","getToProperties","add","gsapAnimation","fromTo","set","scrollTrigger","debugMode","hasAttributes","hasAttribute","parentElement","dataset","onscrollScreen","animateFrom","getAnimateFrom","offset","getOffsetAndDistance","_extends","bottom","top","x","getDirection","y","animateTo","getAnimateTo","getX","getY","ease","start","getStart","end","getEnd","invalidateOnRefresh","scrub","getScrub","markers","attrs","every","attr","JSON","parse","onscrollFrom","onscrollTo","getOffset","parseInt","onscrollOffset","onscrollDirection","getDistanceOrSpeed","distance","triggerHeight","offsetHeight","offsetValue","distanceValue","split","trim","endsWith","parseFloat","viewportHeight","window","innerHeight","scrollSpeed","onscrollSpeed","additionalDistance","includes","speed","percentage","map","triggerElement","autoDistance","Math","abs","scrollDistance","onscrollDelay","onscrollStart","onscrollEnd","console","group","log","triggerStart","triggerEnd","auto","offsetBefore","offsetAfter","delay","ScrollTrigger","maxScroll","direction","reverse","groupEnd","refresh","restart","stop","getAll","kill","target","animationData","get","delete","clear","update","destroy"],"mappings":"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"}