{"version":3,"file":"OnscrollDetection.js","sources":["../src/index.js"],"sourcesContent":["export default class OnscrollDetection {\n\tconstructor(options = {}) {\n\t\t// Initialise class properties with default values or provided options\n\t\tthis.elements = options.elements || '[data-onscroll]'\n\t\tthis.screen = options.screen || '(min-width: 1025px)'\n\t\tthis.triggers = new Map()\n\n\t\t// Initialise the class\n\t\tthis.init()\n\t}\n\n\t// Initialisation function\n\tinit() {\n\t\t// Convert elements to an array and loop through each\n\t\tgsap.utils.toArray(this.elements).forEach((element, index) => {\n\t\t\t// Get the trigger element\n\t\t\tconst trigger = this.getTrigger(element)\n\n\t\t\t// Get the screen media query\n\t\t\tconst screen = this.getScreen(element)\n\n\t\t\t// Create a matchMedia instance\n\t\t\tconst matchMedia = gsap.matchMedia()\n\n\t\t\t// Get the animation properties for 'from' state\n\t\t\tconst fromProperties = this.getFromProperties(element, index)\n\n\t\t\t// Get the animation properties for 'to' state\n\t\t\tconst toProperties = this.getToProperties(element, index, trigger)\n\n\t\t\t// Add the animation to the matchMedia instance and store the ScrollTrigger instance\n\t\t\tconst animation = matchMedia.add(screen, () => {\n\t\t\t\tconst gsapAnimation = gsap.fromTo(element, fromProperties, toProperties)\n\t\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t\telement,\n\t\t\t\t\tfromProperties,\n\t\t\t\t\ttoProperties,\n\t\t\t\t\tgsapAnimation,\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// Enable debug mode for logging\n\t\t\tthis.debugMode(element, index)\n\t\t})\n\t}\n\n\t// Helper methods\n\n\t// Get the trigger element for ScrollTrigger\n\tgetTrigger(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto']) && !element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-auto is present and data-onscroll-trigger is not, use the parent element as the trigger\n\t\t\treturn element.parentElement\n\t\t} else if (element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-trigger is present, try to find the DOM element specified by the attribute\n\t\t\tlet triggerElement = document.querySelector(element.dataset.onscrollTrigger);\n\t\t\tif (triggerElement) {\n\t\t\t\treturn triggerElement;\n\t\t\t} else {\n\t\t\t\tconsole.error(`Element specified by data-onscroll-trigger not found: ${element.dataset.onscrollTrigger}`);\n\t\t\t\treturn element;\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise, use the element itself as the trigger\n\t\t\treturn element\n\t\t}\n\t}\n\n\t// Get the screen media query\n\tgetScreen(element) {\n\t\treturn element.hasAttribute('data-onscroll-screen') ? element.dataset.onscrollScreen : this.screen\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetFromProperties(element, index) {\n\t\tconst animateFrom = this.getAnimateFrom(element)\n\t\tconst { offset } = this.getOffsetAndDistance(element)\n\n\t\treturn {\n\t\t\t...animateFrom,\n\t\t\tbottom: this.hasAttributes(element, ['data-onscroll-auto', 'data-onscroll-reverse']) ? 'auto' : null,\n\t\t\ttop:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-auto']) &&\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-reverse'])\n\t\t\t\t\t? 'auto'\n\t\t\t\t\t: null,\n\t\t\tx:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t\ty:\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t}\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetToProperties(element, index, trigger) {\n\t\tconst animateTo = this.getAnimateTo(element)\n\t\tconst { offset } = this.getOffsetAndDistance(element)\n\n\t\treturn {\n\t\t\t...animateTo,\n\t\t\tx: this.getX(element),\n\t\t\ty: this.getY(element),\n\t\t\tease: 'none',\n\t\t\tscrollTrigger: {\n\t\t\t\ttrigger: trigger,\n\t\t\t\tstart: this.getStart(element),\n\t\t\t\tend: this.getEnd(element),\n\t\t\t\tinvalidateOnRefresh: true,\n\t\t\t\tscrub: this.getScrub(element),\n\t\t\t\tmarkers: this.hasAttributes(element, ['data-onscroll-debug']),\n\t\t\t},\n\t\t}\n\t}\n\n\t// Check if an element has all the specified attributes\n\thasAttributes(element, attrs) {\n\t\treturn attrs.every((attr) => element.hasAttribute(attr))\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetAnimateFrom(element) {\n\t\treturn element.hasAttribute('data-onscroll-from') ? JSON.parse(element.dataset.onscrollFrom) : []\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetAnimateTo(element) {\n\t\treturn element.hasAttribute('data-onscroll-to') ? JSON.parse(element.dataset.onscrollTo) : []\n\t}\n\n\t// Get the offset value\n\tgetOffset(element) {\n\t\treturn element.hasAttribute('data-onscroll-offset') ? parseInt(element.dataset.onscrollOffset) : null\n\t}\n\n\t// Get the scroll direction\n\tgetDirection(element) {\n\t\treturn element.dataset.onscrollDirection\n\t}\n\n\t// Get the 'x' value for ScrollTrigger animation\n\tgetX(element) {\n\t\tif (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the 'y' value for ScrollTrigger animation\n\tgetY(element) {\n\t\tif (\n\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the offset and distance values\n\tgetOffsetAndDistance(element) {\n\t\tlet offset = null\n\t\tlet distance = null\n\t\tconst triggerElement = this.getTrigger(element)\n\t\tconst triggerHeight = triggerElement.offsetHeight\n\n\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\n\t\t\t// If the offset value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (offsetValue.trim().endsWith('%')) {\n\t\t\t\tconst offsetPercentage = parseFloat(offsetValue) / 100\n\t\t\t\toffset = offsetPercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\toffset = parseFloat(offsetValue)\n\t\t\t}\n\n\t\t\t// If the distance value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (distanceValue.trim().endsWith('%')) {\n\t\t\t\tconst distancePercentage = parseFloat(distanceValue) / 100\n\t\t\t\tdistance = distancePercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\tdistance = parseFloat(distanceValue)\n\t\t\t}\n\t\t}\n\n\t\treturn { offset, distance }\n\t}\n\n\t// Get the distance or speed value for ScrollTrigger animation\n\tgetDistanceOrSpeed(element) {\n\t\tconst { distance } = this.getOffsetAndDistance(element)\n\t\tconst viewportHeight = window.innerHeight\n\t\tlet scrollSpeed = element.dataset.onscrollSpeed\n\t\tlet additionalDistance = 0\n\n\t\t// Check if there are two values\n\t\tif (scrollSpeed && scrollSpeed.includes(',')) {\n\t\t\tconst [speed, percentage] = scrollSpeed.split(',').map(parseFloat)\n\n\t\t\t// Update the scrollSpeed and calculate the additional distance\n\t\t\tscrollSpeed = speed\n\t\t\tadditionalDistance = (percentage / 100) * viewportHeight\n\n\t\t\t// If scrollSpeed is negative, subtract the additional distance\n\t\t\tif (scrollSpeed < 0) {\n\t\t\t\tadditionalDistance *= -1\n\t\t\t}\n\t\t} else {\n\t\t\tscrollSpeed = parseFloat(scrollSpeed || '0')\n\t\t}\n\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto'])) {\n\t\t\tconst triggerElement = this.getTrigger(element)\n\t\t\tconst autoDistance = Math.abs(triggerElement.offsetHeight - element.offsetHeight)\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -autoDistance : autoDistance\n\t\t} else if (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\tconst elementHeight = element.offsetHeight\n\t\t\tconst scrollDistance = scrollSpeed * elementHeight + additionalDistance\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -scrollDistance : scrollDistance\n\t\t} else if (distance !== null) {\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -distance : distance\n\t\t}\n\t}\n\n\t// Get the delay value which controls the scrub setting\n\tgetScrub(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-delay'])) {\n\t\t\treturn parseInt(element.dataset.onscrollDelay)\n\t\t} else {\n\t\t\treturn true // Default scrub value if no 'data-onscroll-delay' attribute is present\n\t\t}\n\t}\n\n\t// Get the start value for ScrollTrigger animation\n\tgetStart(element) {\n\t\treturn element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top bottom'\n\t}\n\n\t// Get the end value for ScrollTrigger animation\n\tgetEnd(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-speed']) && !element.hasAttribute('data-onscroll-end')) {\n\t\t\tconst scrollDistance = this.getDistanceOrSpeed(element)\n\t\t\tconst { distance } = this.getOffsetAndDistance(element)\n\n\t\t\treturn `bottom${scrollDistance >= 0 ? '+=' : '-='}${Math.abs(scrollDistance)} top`\n\t\t} else {\n\t\t\treturn element.dataset.onscrollEnd ? element.dataset.onscrollEnd : 'bottom top'\n\t\t}\n\t}\n\n\t// Enable debug mode for logging\n\tdebugMode(element, index) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-debug'])) {\n\t\t\tconst { offset, distance } = this.getOffsetAndDistance(element)\n\t\t\tconsole.group(`OnscrollDetection() debug instance (#${index + 1})`)\n\t\t\tconsole.log({\n\t\t\t\telement: element,\n\t\t\t\ttrigger: this.getTrigger(element),\n\t\t\t\ttriggerStart: this.getStart(element),\n\t\t\t\ttriggerEnd: this.getEnd(element),\n\t\t\t\tauto: this.hasAttributes(element, ['data-onscroll-auto']),\n\t\t\t\toffsetBefore: offset,\n\t\t\t\toffsetAfter: this.getDistanceOrSpeed(element),\n\t\t\t\tdelay: this.getScrub(element),\n\t\t\t\tscreen: this.getScreen(element),\n\t\t\t\tspeed: this.hasAttributes(element, ['data-onscroll-speed'])\n\t\t\t\t\t? element.dataset.onscrollSpeed +\n\t\t\t\t\t  ' calculated at ' +\n\t\t\t\t\t  (1 - parseFloat(element.dataset.onscrollSpeed)) *\n\t\t\t\t\t\t\t(ScrollTrigger.maxScroll(window) - (this.scrollTrigger ? this.scrollTrigger.start : 0))\n\t\t\t\t\t: null,\n\t\t\t\tdirection: this.hasAttributes(element, ['data-onscroll-direction'])\n\t\t\t\t\t? element.dataset.onscrollDirection\n\t\t\t\t\t: 'y',\n\t\t\t\treverse: this.hasAttributes(element, ['data-onscroll-reverse']),\n\t\t\t\tanimateFrom: this.getAnimateFrom(element),\n\t\t\t\tanimateTo: this.getAnimateTo(element),\n\t\t\t})\n\t\t\tconsole.groupEnd()\n\t\t}\n\t}\n\n\t// Refresh ScrollTrigger instances\n\trefresh() {\n\t\tScrollTrigger.refresh()\n\t}\n\n\t// Restart the animations and reinitialize the ScrollTrigger instances\n\trestart() {\n\t\t// Stop the current animations and remove ScrollTriggers\n\t\tthis.stop()\n\n\t\t// Kill all existing ScrollTrigger instances\n\t\tScrollTrigger.getAll().forEach((trigger) => trigger.kill())\n\n\t\t// Refresh ScrollTrigger\n\t\tScrollTrigger.refresh()\n\n\t\t// Reapply animations and initialize ScrollTrigger\n\t\tthis.init()\n\t}\n\n\t// Stop animations and ScrollTriggers\n\tstop(target = null) {\n\t\tif (target) {\n\t\t\t// Stop animation and remove the ScrollTrigger for a specific target\n\t\t\tconst animationData = this.triggers.get(target)\n\t\t\tif (animationData) {\n\t\t\t\tanimationData.gsapAnimation.kill()\n\t\t\t\tthis.triggers.delete(target)\n\t\t\t}\n\t\t} else {\n\t\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\t\tthis.triggers.forEach(({ gsapAnimation }) => {\n\t\t\t\tgsapAnimation.kill()\n\t\t\t})\n\t\t\tthis.triggers.clear()\n\t\t}\n\t}\n\n\t// Update animation for a specific target with new fromProperties and toProperties\n\tupdate(target, fromProperties, toProperties) {\n\t\tconst animationData = this.triggers.get(target)\n\n\t\tif (animationData) {\n\t\t\t// Stop the existing animation\n\t\t\tanimationData.gsapAnimation.kill()\n\n\t\t\t// Reinitialize the animation with updated properties\n\t\t\tconst gsapAnimation = gsap.fromTo(animationData.element, fromProperties, toProperties)\n\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t...animationData,\n\t\t\t\tfromProperties,\n\t\t\t\ttoProperties,\n\t\t\t\tgsapAnimation,\n\t\t\t})\n\t\t}\n\t}\n\n\t// Destroy the OnscrollDetection instance\n\tdestroy() {\n\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\tthis.stop()\n\t\tthis.triggers = null\n\t}\n}\n"],"names":["OnscrollDetection","options","this","elements","screen","triggers","Map","init","_proto","prototype","_this","gsap","utils","toArray","forEach","element","index","trigger","getTrigger","getScreen","matchMedia","fromProperties","getFromProperties","toProperties","getToProperties","add","gsapAnimation","fromTo","set","scrollTrigger","debugMode","hasAttributes","hasAttribute","parentElement","document","querySelector","dataset","onscrollTrigger","console","error","onscrollScreen","animateFrom","getAnimateFrom","offset","getOffsetAndDistance","_extends","bottom","top","x","getDirection","y","animateTo","getAnimateTo","getX","getY","ease","start","getStart","end","getEnd","invalidateOnRefresh","scrub","getScrub","markers","attrs","every","attr","JSON","parse","onscrollFrom","onscrollTo","getOffset","parseInt","onscrollOffset","onscrollDirection","getDistanceOrSpeed","distance","triggerHeight","offsetHeight","_element$dataset$onsc","split","offsetValue","distanceValue","trim","endsWith","parseFloat","viewportHeight","window","innerHeight","scrollSpeed","onscrollSpeed","additionalDistance","includes","_scrollSpeed$split$ma","map","triggerElement","autoDistance","Math","abs","scrollDistance","onscrollDelay","onscrollStart","onscrollEnd","_this$getOffsetAndDis5","group","log","triggerStart","triggerEnd","auto","offsetBefore","offsetAfter","delay","speed","ScrollTrigger","maxScroll","direction","reverse","groupEnd","refresh","restart","stop","getAll","kill","target","animationData","get","_ref","clear","update","destroy"],"mappings":"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"}