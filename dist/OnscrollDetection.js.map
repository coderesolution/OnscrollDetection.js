{"version":3,"file":"OnscrollDetection.js","sources":["../src/index.js"],"sourcesContent":["export default class OnscrollDetection {\n\tconstructor(options = {}) {\n\t\t// Initialise class properties with default values or provided options\n\t\tthis.elements = options.elements || '[data-onscroll]'\n\t\tthis.screen = options.screen || '(min-width: 768px)'\n\t\tthis.triggers = new Map()\n\n\t\t// Initialise the class\n\t\tthis.init()\n\t}\n\n\t// Initialisation function\n\tinit() {\n\t\t// Convert elements to an array and loop through each\n\t\tgsap.utils.toArray(this.elements).forEach((element, index) => {\n\t\t\t// Get the trigger element\n\t\t\tconst trigger = this.getTrigger(element)\n\n\t\t\t// Get the screen media query\n\t\t\tconst screen = this.getScreen(element)\n\n\t\t\t// Create a matchMedia instance\n\t\t\tconst matchMedia = gsap.matchMedia()\n\n\t\t\t// Get the animation properties for 'from' state\n\t\t\tconst fromProperties = this.getFromProperties(element, index)\n\n\t\t\t// Get the animation properties for 'to' state\n\t\t\tconst toProperties = this.getToProperties(element, index, trigger)\n\n\t\t\t// Add the animation to the matchMedia instance and store the ScrollTrigger instance\n\t\t\tconst animation = matchMedia.add(screen, () => {\n\t\t\t\tconst gsapAnimation = gsap.fromTo(element, fromProperties, toProperties)\n\t\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t\telement,\n\t\t\t\t\tfromProperties,\n\t\t\t\t\ttoProperties,\n\t\t\t\t\tgsapAnimation,\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// Enable debug mode for logging\n\t\t\tthis.debugMode(element, index)\n\t\t})\n\t}\n\n\t// Helper methods\n\n\t// Get the trigger element for ScrollTrigger\n\tgetTrigger(element) {\n\t\treturn element.hasAttribute('data-onscroll-auto') ? element.parentElement : element\n\t}\n\n\t// Get the screen media query\n\tgetScreen(element) {\n\t\treturn element.hasAttribute('data-onscroll-screen') ? element.dataset.onscrollScreen : this.screen\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetFromProperties(element, index) {\n\t\tconst animateFrom = this.getAnimateFrom(element)\n\t\tconst offset = this.getOffset(element)\n\n\t\treturn {\n\t\t\t...animateFrom,\n\t\t\tbottom: this.hasAttributes(element, ['data-onscroll-auto', 'data-onscroll-reverse']) ? 'auto' : null,\n\t\t\ttop:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-auto']) &&\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-reverse'])\n\t\t\t\t\t? 'auto'\n\t\t\t\t\t: null,\n\t\t\tx:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t\ty:\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t}\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetToProperties(element, index, trigger) {\n\t\tconst animateTo = this.getAnimateTo(element)\n\n\t\treturn {\n\t\t\t...animateTo,\n\t\t\tx: this.getX(element),\n\t\t\ty: this.getY(element),\n\t\t\tease: 'none',\n\t\t\tscrollTrigger: {\n\t\t\t\ttrigger: trigger,\n\t\t\t\tstart: this.getStart(element),\n\t\t\t\tend: this.getEnd(element),\n\t\t\t\tinvalidateOnRefresh: true,\n\t\t\t\tscrub: this.getScrub(element), // Use the getScrub function here\n\t\t\t\tmarkers: this.hasAttributes(element, ['data-onscroll-debug']),\n\t\t\t},\n\t\t}\n\t}\n\n\t// Check if an element has all the specified attributes\n\thasAttributes(element, attrs) {\n\t\treturn attrs.every((attr) => element.hasAttribute(attr))\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetAnimateFrom(element) {\n\t\treturn element.hasAttribute('data-onscroll-from') ? JSON.parse(element.dataset.onscrollFrom) : []\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetAnimateTo(element) {\n\t\treturn element.hasAttribute('data-onscroll-to') ? JSON.parse(element.dataset.onscrollTo) : []\n\t}\n\n\t// Get the offset value\n\tgetOffset(element) {\n\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\tconst offsetValue = element.dataset.onscrollOffset;\n\t\t\tif (offsetValue.endsWith('%')) {\n\t\t\t\t// Assuming the offset is relative to the height of the element\n\t\t\t\tconst percentage = parseInt(offsetValue.slice(0, -1));\n\t\t\t\treturn element.offsetHeight * (percentage / 100);\n\t\t\t} else if (offsetValue.endsWith('px')) {\n\t\t\t\treturn parseInt(offsetValue.slice(0, -2));\n\t\t\t} else {\n\t\t\t\treturn parseInt(offsetValue);\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t// Get the scroll direction\n\tgetDirection(element) {\n\t\treturn element.dataset.onscrollDirection\n\t}\n\n\t// Get the 'x' value for ScrollTrigger animation\n\tgetX(element) {\n\t\tif (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the 'y' value for ScrollTrigger animation\n\tgetY(element) {\n\t\tif (\n\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the distance or speed value for ScrollTrigger animation\n\tgetDistanceOrSpeed(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\treturn (\n\t\t\t\t(1 - parseFloat(element.dataset.onscrollSpeed)) *\n\t\t\t\t(ScrollTrigger.maxScroll(window) - (this.scrollTrigger ? this.scrollTrigger.start : 0))\n\t\t\t)\n\t\t} else {\n\t\t\tif (element.hasAttribute('data-onscroll-distance')) {\n\t\t\t\tconst distanceValue = element.dataset.onscrollDistance;\n\t\t\t\tlet distance;\n\t\t\t\tif (distanceValue.endsWith('%')) {\n\t\t\t\t\t// Assuming the distance is relative to the height of the element\n\t\t\t\t\tconst percentage = parseInt(distanceValue.slice(0, -1));\n\t\t\t\t\tdistance = element.offsetHeight * (percentage / 100);\n\t\t\t\t} else if (distanceValue.endsWith('px')) {\n\t\t\t\t\tdistance = parseInt(distanceValue.slice(0, -2));\n\t\t\t\t} else {\n\t\t\t\t\tdistance = parseInt(distanceValue);\n\t\t\t\t}\n\t\t\t\tif (this.hasAttributes(element, ['data-onscroll-auto'])) {\n\t\t\t\t\tdistance = element.offsetHeight - element.parentElement.offsetHeight;\n\t\t\t\t}\n\t\t\t\tif (this.hasAttributes(element, ['data-onscroll-reverse'])) {\n\t\t\t\t\treturn -distance;\n\t\t\t\t}\n\t\t\t\treturn distance;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get the delay value which controls the scrub setting\n\tgetScrub(element) {\n\t\tif (element.hasAttribute('data-onscroll-delay')) {\n\t\t\tlet delayValue = element.dataset.onscrollDelay;\n\t\t\t// Assuming the delayValue can be either an integer or a boolean\n\t\t\tif (delayValue === 'true') {\n\t\t\t\treturn true;\n\t\t\t} else if (delayValue === 'false') {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\t// Assuming the delayValue is an integer.\n\t\t\t\t// Parse it to int and return.\n\t\t\t\treturn parseInt(delayValue);\n\t\t\t}\n\t\t} else {\n\t\t\treturn true;  // Default scrub value if no 'data-onscroll-delay' attribute is present\n\t\t}\n\t}\n\n\t// Get the start value for ScrollTrigger animation\n\tgetStart(element) {\n\t\tif (element.hasAttribute('data-onscroll-start')) {\n\t\t\treturn element.dataset.onscrollStart;\n\t\t} else {\n\t\t\tconst offset = this.getOffset(element);\n\t\t\tconst reverse = this.hasAttributes(element, ['data-onscroll-reverse']);\n\n\t\t\t// If reverse is true, deduct the offset, otherwise add it\n\t\t\tconst adjustedOffset = reverse ? -offset : offset;\n\n\t\t\t// Assuming the default start is 'top bottom'\n\t\t\t// We'll add the offset to both 'top' and 'bottom' values\n\t\t\tconst [top, bottom] = ['top', 'bottom'].map(value => `${value}+=${adjustedOffset}`);\n\t\t\treturn `${top} ${bottom}`;\n\t\t}\n\t}\n\n\t// Get the end value for ScrollTrigger animation\n\tgetEnd(element) {\n\t\tif (element.hasAttribute('data-onscroll-end')) {\n\t\t\treturn element.dataset.onscrollEnd;\n\t\t} else {\n\t\t\tconst offset = this.getOffset(element);\n\t\t\tconst reverse = this.hasAttributes(element, ['data-onscroll-reverse']);\n\n\t\t\t// If reverse is true, add the offset, otherwise deduct it\n\t\t\tconst adjustedOffset = reverse ? offset : -offset;\n\n\t\t\t// Assuming the default end is 'bottom top'\n\t\t\t// We'll add the offset to both 'bottom' and 'top' values\n\t\t\tconst [bottom, top] = ['bottom', 'top'].map(value => `${value}+=${adjustedOffset}`);\n\t\t\treturn `${bottom} ${top}`;\n\t\t}\n\t}\n\n\t// Enable debug mode for logging\n\tdebugMode(element, index) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-debug'])) {\n\t\t\tconsole.group(`OnscrollDetection() debug instance (${index + 1})`)\n\t\t\tconsole.log({\n\t\t\t\telement: element,\n\t\t\t\ttrigger: this.getTrigger(element),\n\t\t\t\ttriggerStart: this.getStart(element),\n\t\t\t\ttriggerEnd: this.getEnd(element),\n\t\t\t\tauto: this.hasAttributes(element, ['data-onscroll-auto']),\n\t\t\t\toffset: this.getOffset(element),\n\t\t\t\tdistance: this.getDistanceOrSpeed(element),\n\t\t\t\tdelay: this.getScrub(element),\n\t\t\t\tscreen: this.getScreen(element),\n\t\t\t\tspeed: this.hasAttributes(element, ['data-onscroll-speed'])\n\t\t\t\t\t? element.dataset.onscrollSpeed +\n\t\t\t\t\t  ' calculated at ' +\n\t\t\t\t\t  (1 - parseFloat(element.dataset.onscrollSpeed)) *\n\t\t\t\t\t\t\t(ScrollTrigger.maxScroll(window) - (this.scrollTrigger ? this.scrollTrigger.start : 0))\n\t\t\t\t\t: null,\n\t\t\t\tdirection: this.hasAttributes(element, ['data-onscroll-direction'])\n\t\t\t\t\t? element.dataset.onscrollDirection\n\t\t\t\t\t: 'y',\n\t\t\t\treverse: this.hasAttributes(element, ['data-onscroll-reverse']),\n\t\t\t\tanimateFrom: this.getAnimateFrom(element),\n\t\t\t\tanimateTo: this.getAnimateTo(element),\n\t\t\t})\n\t\t\tconsole.groupEnd()\n\t\t}\n\t}\n\n\t// Refresh ScrollTrigger instances\n\trefresh() {\n\t\tScrollTrigger.refresh()\n\t}\n\n\t// Restart the animations and reinitialize the ScrollTrigger instances\n\trestart() {\n\t\t// Stop the current animations and remove ScrollTriggers\n\t\tthis.stop()\n\n\t\t// Kill all existing ScrollTrigger instances\n\t\tScrollTrigger.getAll().forEach((trigger) => trigger.kill())\n\n\t\t// Refresh ScrollTrigger\n\t\tScrollTrigger.refresh()\n\n\t\t// Reapply animations and initialize ScrollTrigger\n\t\tthis.init()\n\t}\n\n\t// Stop animations and ScrollTriggers\n\tstop(target = null) {\n\t\tif (target) {\n\t\t\t// Stop animation and remove the ScrollTrigger for a specific target\n\t\t\tconst animationData = this.triggers.get(target)\n\t\t\tif (animationData) {\n\t\t\t\tanimationData.gsapAnimation.kill()\n\t\t\t\tthis.triggers.delete(target)\n\t\t\t}\n\t\t} else {\n\t\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\t\tthis.triggers.forEach(({ gsapAnimation }) => {\n\t\t\t\tgsapAnimation.kill()\n\t\t\t})\n\t\t\tthis.triggers.clear()\n\t\t}\n\t}\n\n\t// Update animation for a specific target with new fromProperties and toProperties\n\tupdate(target, fromProperties, toProperties) {\n\t\tconst animationData = this.triggers.get(target)\n\n\t\tif (animationData) {\n\t\t\t// Stop the existing animation\n\t\t\tanimationData.gsapAnimation.kill()\n\n\t\t\t// Reinitialize the animation with updated properties\n\t\t\tconst gsapAnimation = gsap.fromTo(animationData.element, fromProperties, toProperties)\n\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t...animationData,\n\t\t\t\tfromProperties,\n\t\t\t\ttoProperties,\n\t\t\t\tgsapAnimation,\n\t\t\t})\n\t\t}\n\t}\n\n\t// Destroy the OnscrollDetection instance\n\tdestroy() {\n\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\tthis.stop()\n\t\tthis.triggers = null\n\t}\n}\n"],"names":["OnscrollDetection","options","this","elements","screen","triggers","Map","init","_proto","prototype","_this","gsap","utils","toArray","forEach","element","index","trigger","getTrigger","getScreen","matchMedia","fromProperties","getFromProperties","toProperties","getToProperties","add","gsapAnimation","fromTo","set","scrollTrigger","debugMode","hasAttribute","parentElement","dataset","onscrollScreen","animateFrom","getAnimateFrom","offset","getOffset","_extends","bottom","hasAttributes","top","x","getDirection","y","getAnimateTo","getX","getY","ease","start","getStart","end","getEnd","invalidateOnRefresh","scrub","getScrub","markers","attrs","every","attr","JSON","parse","onscrollFrom","onscrollTo","offsetValue","onscrollOffset","endsWith","percentage","parseInt","slice","offsetHeight","onscrollDirection","getDistanceOrSpeed","parseFloat","onscrollSpeed","ScrollTrigger","maxScroll","window","distance","distanceValue","onscrollDistance","delayValue","onscrollDelay","onscrollStart","adjustedOffset","_map","map","value","onscrollEnd","_map2","console","group","log","triggerStart","triggerEnd","auto","delay","speed","direction","reverse","animateTo","groupEnd","refresh","restart","stop","getAll","kill","target","animationData","get","_ref","clear","update","destroy"],"mappings":"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"}