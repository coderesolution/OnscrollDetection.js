{"version":3,"file":"OnscrollDetection.js","sources":["../src/index.js"],"sourcesContent":["export default class OnscrollDetection {\n\tconstructor(options = {}) {\n\t\t// Initialise class properties with default values or provided options\n\t\tthis.elements = options.elements || '[data-onscroll]'\n\t\tthis.screen = options.screen || '(min-width: 1025px)'\n\t\tthis.triggers = new Map()\n\t\tthis.debug = options.debug || false\n\n\t\t// Set class names to defaults or provided options\n\t\tthis.scrollingClass = options.scrollingClass || 'is-scrolling'\n\t\tthis.scrolledClass = options.scrolledClass || 'has-scrolled'\n\t\tthis.stickyClass = options.stickyClass || 'is-sticky'\n\t\tthis.stuckClass = options.stuckClass || 'has-stuck'\n\n\t\t// Initialise event handlers\n\t\tthis.eventHandlers = {}\n\n\t\t// Set autoStart to true by default, or use provided value\n\t\tthis.autoStart = options.autoStart !== undefined ? options.autoStart : true\n\n\t\t// Initialise the class\n\t\tif (this.autoStart) {\n\t\t\tthis.init()\n\t\t}\n\t}\n\n\t// Initialisation function\n\tinit() {\n\t\t// Convert elements to an array and loop through each\n\t\tgsap.utils.toArray(this.elements).forEach((element, index) => {\n\t\t\t// Get the trigger element\n\t\t\tconst trigger = this.getTrigger(element)\n\n\t\t\t// Get the screen media query\n\t\t\tconst screen = this.getScreen(element)\n\n\t\t\t// Create a matchMedia instance\n\t\t\tconst matchMedia = gsap.matchMedia()\n\n\t\t\t// Get the animation properties for 'from' state\n\t\t\tconst fromProperties = this.getFromProperties(element, index)\n\n\t\t\tfromProperties.startAt = { backgroundColor: 'red' }\n\t\t\tfromProperties.immediateRender = true\n\n\t\t\t// Get the animation properties for 'to' state\n\t\t\tconst toProperties = this.getToProperties(element, index, trigger)\n\n\t\t\t// Add the animation to the matchMedia instance and store the ScrollTrigger instance\n\t\t\tconst animation = matchMedia.add(screen, () => {\n\t\t\t\tconst gsapAnimation = gsap.fromTo(element, fromProperties, toProperties)\n\n\t\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t\telement,\n\t\t\t\t\tfromProperties,\n\t\t\t\t\ttoProperties,\n\t\t\t\t\tgsapAnimation,\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// Enable debug mode for logging\n\t\t\tthis.debugMode(element, index)\n\t\t})\n\t}\n\n\t// Function to load and initialize the class\n\tstart() {\n\t\t// Initialize the class\n\t\tthis.init()\n\t}\n\n\t// Events\n\ton(event, handler) {\n\t\tif (!this.eventHandlers[event]) {\n\t\t\tthis.eventHandlers[event] = []\n\t\t}\n\t\tthis.eventHandlers[event].push(handler)\n\t}\n\n\temit(event, ...args) {\n\t\tif (this.eventHandlers[event]) {\n\t\t\tthis.eventHandlers[event].forEach((handler) => handler(...args))\n\t\t}\n\t}\n\n\t// Get the trigger element for ScrollTrigger\n\tgetTrigger(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto']) && !element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-auto is present and data-onscroll-trigger is not, use the parent element as the trigger\n\t\t\treturn element.parentElement\n\t\t} else if (element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-trigger is present, try to find the DOM element specified by the attribute\n\t\t\tlet triggerElement = document.querySelector(element.dataset.onscrollTrigger)\n\t\t\tif (triggerElement) {\n\t\t\t\treturn triggerElement\n\t\t\t} else {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`Element specified by data-onscroll-trigger not found: ${element.dataset.onscrollTrigger}`\n\t\t\t\t)\n\t\t\t\treturn element\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise, use the element itself as the trigger\n\t\t\treturn element\n\t\t}\n\t}\n\n\t// Get the screen media query\n\tgetScreen(element) {\n\t\treturn element.hasAttribute('data-onscroll-screen') ? element.dataset.onscrollScreen : this.screen\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetFromProperties(element, index) {\n\t\tconst animateFrom = this.getAnimateFrom(element)\n\t\tconst { offset } = this.getOffsetAndDistance(element)\n\n\t\treturn {\n\t\t\t...animateFrom,\n\t\t\tbottom: this.hasAttributes(element, ['data-onscroll-auto', 'data-onscroll-reverse']) ? 'auto' : null,\n\t\t\ttop:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-auto']) &&\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-reverse'])\n\t\t\t\t\t? 'auto'\n\t\t\t\t\t: null,\n\t\t\tx:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t\ty:\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t}\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetToProperties(element, index, trigger) {\n\t\tconst animateTo = this.getAnimateTo(element)\n\t\tconst stickyProperties = this.getStickyProperties(element)\n\t\tconst isSticky = this.hasAttributes(element, ['data-onscroll-sticky'])\n\t\tconst customEventName = element.getAttribute('data-onscroll-call')\n\t\tconst progressEventName = element.getAttribute('data-onscroll-progress')\n\n\t\t// Helper function to dispatch the custom event\n\t\tconst dispatchCustomEvent = (when, direction) => {\n\t\t\tif (customEventName) {\n\t\t\t\twindow.dispatchEvent(\n\t\t\t\t\tnew CustomEvent(customEventName, {\n\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\ttarget: element,\n\t\t\t\t\t\t\tdirection: direction === 1 ? 'down' : 'up',\n\t\t\t\t\t\t\twhen,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\t// Helper function to dispatch progress event\n\t\tconst dispatchProgressEvent = (progress, direction) => {\n\t\t\tif (progressEventName) {\n\t\t\t\twindow.dispatchEvent(\n\t\t\t\t\tnew CustomEvent(progressEventName, {\n\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\telement: element,\n\t\t\t\t\t\t\tprogress: progress,\n\t\t\t\t\t\t\tdirection: direction === 1 ? 'down' : 'up'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t...animateTo,\n\t\t\tx: this.getX(element),\n\t\t\ty: this.getY(element),\n\t\t\tease: 'none',\n\t\t\tscrollTrigger: {\n\t\t\t\ttrigger: isSticky ? element : trigger,\n\t\t\t\tstart: this.getStart(element),\n\t\t\t\tend: this.getEnd(element),\n\t\t\t\tinvalidateOnRefresh: true,\n\t\t\t\tpin: stickyProperties.pin,\n\t\t\t\tpinSpacing: stickyProperties.pinSpacing,\n\t\t\t\tscrub: this.getScrub(element),\n\t\t\t\tmarkers: this.hasAttributes(element, ['data-onscroll-debug']),\n\t\t\t\tonUpdate: self => {\n\t\t\t\t\tlet progress = self.progress.toFixed(2);\n\t\t\t\t\telement.style.setProperty('--onscrollProgress', progress);\n\n\t\t\t\t\tif (progressEventName) {\n\t\t\t\t\t\tdispatchProgressEvent(progress, self.direction);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonToggle: self => {\n\t\t\t\t\tif (!self.isActive) {\n\t\t\t\t\t\telement.style.setProperty('--onscrollProgress', 0);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonEnter: ({ direction }) => {\n\t\t\t\t\telement.classList.add(this.scrollingClass, this.scrolledClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.add(this.stickyClass, this.stuckClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onEnter', direction)\n\t\t\t\t\tthis.emit('onEnter', element)\n\t\t\t\t},\n\t\t\t\tonLeave: ({ direction }) => {\n\t\t\t\t\telement.classList.remove(this.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.remove(this.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onLeave', direction)\n\t\t\t\t\tthis.emit('onLeave', element)\n\t\t\t\t},\n\t\t\t\tonEnterBack: ({ direction }) => {\n\t\t\t\t\telement.classList.add(this.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.add(this.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onEnterBack', direction)\n\t\t\t\t\tthis.emit('onEnterBack', element)\n\t\t\t\t},\n\t\t\t\tonLeaveBack: ({ direction }) => {\n\t\t\t\t\telement.classList.remove(this.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.remove(this.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onLeaveBack', direction)\n\t\t\t\t\tthis.emit('onLeaveBack', element)\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\t// Get the sticky properties for ScrollTrigger animation\n\tgetStickyProperties(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn { pin: true, pinSpacing: false }\n\t\t} else {\n\t\t\treturn { pin: false, pinSpacing: true }\n\t\t}\n\t}\n\n\t// Check if an element has all the specified attributes\n\thasAttributes(element, attrs) {\n\t\treturn attrs.every((attr) => element.hasAttribute(attr))\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetAnimateFrom(element) {\n\t\treturn element.hasAttribute('data-onscroll-from') ? JSON.parse(element.dataset.onscrollFrom) : []\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetAnimateTo(element) {\n\t\treturn element.hasAttribute('data-onscroll-to') ? JSON.parse(element.dataset.onscrollTo) : []\n\t}\n\n\t// Get the offset value\n\tgetOffset(element) {\n\t\treturn element.hasAttribute('data-onscroll-offset') ? parseInt(element.dataset.onscrollOffset) : null\n\t}\n\n\t// Get the scroll direction\n\tgetDirection(element) {\n\t\treturn element.dataset.onscrollDirection ? element.dataset.onscrollDirection : 'y'\n\t}\n\n\t// Get the 'x' value for ScrollTrigger animation\n\tgetX(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn null\n\t\t}\n\t\tif (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the 'y' value for ScrollTrigger animation\n\tgetY(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn null\n\t\t}\n\t\tif (\n\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the offset and distance values\n\tgetOffsetAndDistance(element) {\n\t\t// Check if the element has the data-onscroll-sticky attribute\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn { offset: null, distance: null }\n\t\t}\n\n\t\tlet offset = null\n\t\tlet distance = null\n\t\tconst triggerElement = this.getTrigger(element)\n\t\tconst triggerHeight = triggerElement.offsetHeight\n\n\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\n\t\t\t// If the offset value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (offsetValue.trim().endsWith('%')) {\n\t\t\t\tconst offsetPercentage = parseFloat(offsetValue) / 100\n\t\t\t\toffset = offsetPercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\toffset = parseFloat(offsetValue)\n\t\t\t}\n\n\t\t\t// If the distance value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (distanceValue.trim().endsWith('%')) {\n\t\t\t\tconst distancePercentage = parseFloat(distanceValue) / 100\n\t\t\t\tdistance = distancePercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\tdistance = parseFloat(distanceValue)\n\t\t\t}\n\t\t}\n\n\t\treturn { offset, distance }\n\t}\n\n\t// Get the distance or speed value for ScrollTrigger animation\n\tgetDistanceOrSpeed(element) {\n\t\tconst { distance } = this.getOffsetAndDistance(element)\n\t\tconst viewportHeight = window.innerHeight\n\t\tlet scrollSpeed = element.dataset.onscrollSpeed\n\t\tlet additionalDistance = 0\n\n\t\t// Check if there are two values\n\t\tif (scrollSpeed && scrollSpeed.includes(',')) {\n\t\t\tconst [speed, percentage] = scrollSpeed.split(',').map(parseFloat)\n\n\t\t\t// Update the scrollSpeed and calculate the additional distance\n\t\t\tscrollSpeed = speed\n\t\t\tadditionalDistance = (percentage / 100) * viewportHeight\n\n\t\t\t// If scrollSpeed is negative, subtract the additional distance\n\t\t\tif (scrollSpeed < 0) {\n\t\t\t\tadditionalDistance *= -1\n\t\t\t}\n\t\t} else {\n\t\t\tscrollSpeed = parseFloat(scrollSpeed || '0')\n\t\t}\n\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto'])) {\n\t\t\tconst triggerElement = this.getTrigger(element)\n\t\t\tconst autoDistance = Math.abs(triggerElement.offsetHeight - element.offsetHeight)\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -autoDistance : autoDistance\n\t\t} else if (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\tconst elementHeight = element.offsetHeight\n\t\t\tconst scrollDistance = scrollSpeed * elementHeight + additionalDistance\n\t\t\treturn scrollDistance\n\t\t} else if (distance !== null) {\n\t\t\treturn distance\n\t\t}\n\t}\n\n\t// Get the delay value which controls the scrub setting\n\tgetScrub(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-delay'])) {\n\t\t\treturn parseInt(element.dataset.onscrollDelay)\n\t\t} else {\n\t\t\treturn true // Default scrub value if no 'data-onscroll-delay' attribute is present\n\t\t}\n\t}\n\n\t// Get the start value for ScrollTrigger animation\n\tgetStart(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\tlet stickyOffset = 0\n\n\t\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\t\tstickyOffset = parseFloat(offsetValue)\n\t\t\t}\n\n\t\t\treturn (element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top top') + '+=' + stickyOffset\n\t\t} else if (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-preset', 'data-onscroll-offset']) &&\n\t\t\tthis.getDirection(element) !== 'x' &&\n\t\t\t!this.hasAttributes(element, ['data-onscroll-start', 'data-onscroll-sticky'])\n\t\t) {\n\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\tlet positionElement = parseFloat(offsetValue) < 0 ? 'top+=' + offsetValue : 'top+=0'\n\t\t\tlet positionMarker = 'bottom'\n\n\t\t\treturn positionElement + ' ' + positionMarker\n\t\t} else {\n\t\t\treturn element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top bottom'\n\t\t}\n\t}\n\n\t// Get the end value for ScrollTrigger animation\n\tgetEnd(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\tconst trigger = this.getTrigger(element)\n\t\t\tlet stickyOffset = 0\n\n\t\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\t\tstickyOffset = parseFloat(distanceValue)\n\t\t\t}\n\n\t\t\tconst stickyDistance = trigger.clientHeight - element.clientHeight - stickyOffset\n\n\t\t\treturn (element.dataset.onscrollEnd ? element.dataset.onscrollEnd : '+=' + stickyDistance)\n\t\t} else if (this.hasAttributes(element, ['data-onscroll-speed']) && !element.hasAttribute('data-onscroll-end')) {\n\t\t\tconst scrollDistance = this.getDistanceOrSpeed(element)\n\t\t\tconst { distance } = this.getOffsetAndDistance(element)\n\n\t\t\treturn `bottom${scrollDistance >= 0 ? '+=' : '-='}${Math.abs(scrollDistance)} top`\n\t\t} else if (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-preset', 'data-onscroll-offset']) &&\n\t\t\tthis.getDirection(element) !== 'x' &&\n\t\t\t!this.hasAttributes(element, ['data-onscroll-end', 'data-onscroll-sticky'])\n\t\t) {\n\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\tlet positionElement = 'bottom+=' + distanceValue\n\t\t\tlet positionMarker = 'top'\n\n\t\t\treturn positionElement + ' ' + positionMarker\n\t\t} else {\n\t\t\treturn element.dataset.onscrollEnd ? element.dataset.onscrollEnd : 'bottom top'\n\t\t}\n\t}\n\n\t// Enable debug mode for logging\n\tdebugMode(element, index) {\n\t\tif (!this.debug && !this.hasAttributes(element, ['data-onscroll-debug'])) return;\n\n\t\tconst { offset, distance } = this.getOffsetAndDistance(element);\n\t\tlet speedMultiplier;\n\t\tlet speedViewportPercentage;\n\n\t\tif (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\t[speedMultiplier, speedViewportPercentage] = element.dataset.onscrollSpeed.split(',');\n\t\t}\n\n\t\tconst attrs = element.dataset;\n\t\tconst hasSpeed = this.hasAttributes(element, ['data-onscroll-speed']);\n\t\tconst hasPreset = this.hasAttributes(element, ['data-onscroll-preset']);\n\t\tconst hasSticky = this.hasAttributes(element, ['data-onscroll-sticky']);\n\t\tconst hasReverse = this.hasAttributes(element, ['data-onscroll-reverse']);\n\n\t\tconsole.group(`OnscrollDetection() debug instance (#${index + 1})`);\n\t\tconsole.log({\n\t\t\telement: element,\n\t\t\ttrigger: this.getTrigger(element),\n\t\t\ttriggerStart: this.getStart(element),\n\t\t\ttriggerEnd: this.getEnd(element),\n\t\t\tauto: this.hasAttributes(element, ['data-onscroll-auto']),\n\t\t\toffsetBefore: offset,\n\t\t\toffsetAfter: this.getDistanceOrSpeed(element),\n\t\t\tdelay: this.getScrub(element),\n\t\t\tscreen: this.getScreen(element),\n\t\t\tspeed: hasSpeed\n\t\t\t\t? `${parseFloat(\n\t\t\t\t\tspeedMultiplier * element.clientHeight +\n\t\t\t\t\t(speedViewportPercentage / 100) * window.innerHeight\n\t\t\t\t)} (${parseFloat(speedMultiplier)}x element height + ${parseFloat(speedViewportPercentage)}% of the viewport height)`\n\t\t\t\t: null,\n\t\t\tdirection: this.hasAttributes(element, ['data-onscroll-direction'])\n\t\t\t\t? attrs.onscrollDirection\n\t\t\t\t: 'y',\n\t\t\tpreset: hasPreset,\n\t\t\treverse: hasReverse,\n\t\t\tsticky: hasSticky,\n\t\t\tanimateFrom: this.getAnimateFrom(element),\n\t\t\tanimateTo: this.getAnimateTo(element),\n\t\t\tcustomEvent: this.hasAttributes(element, ['data-onscroll-call'])\n\t\t\t\t? attrs.onscrollCall\n\t\t\t\t: null,\n\t\t});\n\n\t\tconst warnings = [\n\t\t\t{condition: this.hasAttributes(element, ['data-onscroll-offset']) && hasSpeed, message: '`offset` and `speed` should not be used together'},\n\t\t\t{condition: hasPreset && (this.hasAttributes(element, ['data-onscroll-start']) || this.hasAttributes(element, ['data-onscroll-end'])), message: '`preset` should not be used in conjunction with `start` or `end` settings'},\n\t\t\t{condition: hasSticky && hasSpeed, message: '`sticky` should not be used in conjunction with `speed`'},\n\t\t\t{condition: hasSticky && this.hasAttributes(element, ['data-onscroll-offset']) && this.hasAttributes(element, ['data-onscroll-end']), message: 'Your bottom `offset` will be ignored due to custom `end` on the `sticky` element'},\n\t\t\t{condition: hasReverse && (!this.hasAttributes(element, ['data-onscroll-auto']) || this.hasAttributes(element, ['data-onscroll-offset']) || hasSticky || hasSpeed), message: '`reverse` is not compatible with `offset`, `speed` or `sticky` and should only be used in conjunction with `auto`'},\n\t\t\t{condition: hasSpeed && hasPreset, message: '`preset` has no effect in conjunction with `speed` setting'},\n\t\t\t{condition: this.getDirection(element) === 'x' && hasPreset, message: '`preset` has no effect in conjunction with `x` direction'}\n\t\t];\n\n\t\twarnings.forEach(warning => warning.condition && console.warn(warning.message));\n\t\tconsole.groupEnd();\n\t}\n\n\t// Fetch a trigger\n\tfetch(elementOrIndex) {\n\t\tif (typeof elementOrIndex === 'number') {\n\t\t\t// Treat argument as an index\n\t\t\tconst keys = Array.from(this.triggers.keys())\n\t\t\treturn keys[elementOrIndex]\n\t\t} else {\n\t\t\t// Assume argument is a DOM element\n\t\t\tlet trigger = null\n\t\t\tthis.triggers.forEach((value, key) => {\n\t\t\t\tif (value.element === elementOrIndex) {\n\t\t\t\t\ttrigger = key\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn trigger\n\t\t}\n\t}\n\n\t// Refresh ScrollTrigger instances\n\trefresh() {\n\t\tScrollTrigger.refresh()\n\n\t\t// Emit event after refresh is done\n\t\tthis.emit('refresh')\n\t}\n\n\t// Restart the animations and reinitialize the ScrollTrigger instances\n\trestart() {\n\t\t// Stop the current animations and remove ScrollTriggers\n\t\tthis.stop()\n\n\t\t// Kill all existing ScrollTrigger instances\n\t\tScrollTrigger.getAll().forEach((trigger) => trigger.kill())\n\n\t\t// Refresh ScrollTrigger\n\t\tScrollTrigger.refresh()\n\n\t\t// Reapply animations and initialize ScrollTrigger\n\t\tthis.init()\n\n\t\t// Emit event after restart is done\n\t\tthis.emit('restart')\n\t}\n\n\t// Stop animations and ScrollTriggers\n\tstop(target = null) {\n\t\tif (target) {\n\t\t\t// Stop animation and remove the ScrollTrigger for a specific target\n\t\t\tconst animationData = this.triggers.get(target)\n\t\t\tif (animationData) {\n\t\t\t\tanimationData.gsapAnimation.kill()\n\t\t\t\tthis.triggers.delete(target)\n\t\t\t}\n\t\t} else {\n\t\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\t\tthis.triggers.forEach(({ gsapAnimation }) => {\n\t\t\t\tgsapAnimation.kill()\n\t\t\t})\n\t\t\tthis.triggers.clear()\n\t\t}\n\n\t\t// Emit event after stop is done\n\t\tthis.emit('stop', target)\n\t}\n\n\t// Update animation for a specific target with new fromProperties and toProperties\n// \tupdate(target, fromProperties, toProperties) {\n// \t\tconst animationData = this.triggers.get(target)\n//\n// \t\tif (animationData) {\n// \t\t\t// Stop the existing animation\n// \t\t\tanimationData.gsapAnimation.kill()\n//\n// \t\t\t// Reinitialize the animation with updated properties\n// \t\t\tconst gsapAnimation = gsap.fromTo(animationData.element, fromProperties, toProperties)\n// \t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n// \t\t\t\t...animationData,\n// \t\t\t\tfromProperties,\n// \t\t\t\ttoProperties,\n// \t\t\t\tgsapAnimation,\n// \t\t\t})\n// \t\t}\n// \t}\n\n\t// Destroy the OnscrollDetection instance\n\tdestroy() {\n\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\tthis.stop()\n\t\tthis.triggers = null\n\t}\n}\n"],"names":["OnscrollDetection","options","this","elements","screen","triggers","Map","debug","scrollingClass","scrolledClass","stickyClass","stuckClass","eventHandlers","autoStart","undefined","init","_proto","prototype","_this","gsap","utils","toArray","forEach","element","index","trigger","getTrigger","getScreen","matchMedia","fromProperties","getFromProperties","startAt","backgroundColor","immediateRender","toProperties","getToProperties","add","gsapAnimation","fromTo","set","scrollTrigger","debugMode","start","on","event","handler","push","emit","_arguments","arguments","apply","slice","call","hasAttributes","hasAttribute","parentElement","document","querySelector","dataset","onscrollTrigger","console","error","onscrollScreen","animateFrom","getAnimateFrom","offset","getOffsetAndDistance","_extends","bottom","top","x","getDirection","y","_this2","animateTo","getAnimateTo","stickyProperties","getStickyProperties","isSticky","customEventName","getAttribute","progressEventName","dispatchCustomEvent","when","direction","window","dispatchEvent","CustomEvent","detail","target","getX","getY","ease","getStart","end","getEnd","invalidateOnRefresh","pin","pinSpacing","scrub","getScrub","markers","onUpdate","self","progress","toFixed","style","setProperty","dispatchProgressEvent","onToggle","isActive","onEnter","_ref","classList","onLeave","_ref2","remove","onEnterBack","_ref3","onLeaveBack","_ref4","attrs","every","attr","JSON","parse","onscrollFrom","onscrollTo","getOffset","parseInt","onscrollOffset","onscrollDirection","getDistanceOrSpeed","distance","triggerHeight","offsetHeight","_element$dataset$onsc","split","offsetValue","distanceValue","trim","endsWith","parseFloat","viewportHeight","innerHeight","scrollSpeed","onscrollSpeed","additionalDistance","includes","_scrollSpeed$split$ma","map","triggerElement","autoDistance","Math","abs","onscrollDelay","stickyOffset","_element$dataset$onsc2","onscrollStart","_element$dataset$onsc3","positionElement","_element$dataset$onsc4","onscrollEnd","clientHeight","scrollDistance","_this$getOffsetAndDis4","speedMultiplier","speedViewportPercentage","_element$dataset$onsc6","hasSpeed","hasPreset","hasSticky","hasReverse","group","log","triggerStart","triggerEnd","auto","offsetBefore","offsetAfter","delay","speed","preset","reverse","sticky","customEvent","onscrollCall","condition","message","warning","warn","groupEnd","fetch","elementOrIndex","Array","from","keys","value","key","refresh","ScrollTrigger","restart","stop","getAll","kill","animationData","get","_ref5","clear","destroy"],"mappings":"2QACC,SAAAA,EAAYC,QAAO,IAAPA,IAAAA,EAAU,CAAA,GAErBC,KAAKC,SAAWF,EAAQE,UAAY,kBACpCD,KAAKE,OAASH,EAAQG,QAAU,sBAChCF,KAAKG,SAAW,IAAIC,IACpBJ,KAAKK,MAAQN,EAAQM,QAAS,EAG9BL,KAAKM,eAAiBP,EAAQO,gBAAkB,eAChDN,KAAKO,cAAgBR,EAAQQ,eAAiB,eAC9CP,KAAKQ,YAAcT,EAAQS,aAAe,YAC1CR,KAAKS,WAAaV,EAAQU,YAAc,YAGxCT,KAAKU,cAAgB,CAAA,EAGrBV,KAAKW,eAAkCC,IAAtBb,EAAQY,WAA0BZ,EAAQY,UAGvDX,KAAKW,WACRX,KAAKa,MAEP,CAAC,IAAAC,EAAAhB,EAAAiB,iBAAAD,EAGDD,KAAA,WAAO,IAAAG,EAENC,KAAAA,KAAKC,MAAMC,QAAQnB,KAAKC,UAAUmB,QAAQ,SAACC,EAASC,GAEnD,IAAMC,EAAUP,EAAKQ,WAAWH,GAG1BnB,EAASc,EAAKS,UAAUJ,GAGxBK,EAAaT,KAAKS,aAGlBC,EAAiBX,EAAKY,kBAAkBP,EAASC,GAEvDK,EAAeE,QAAU,CAAEC,gBAAiB,OAC5CH,EAAeI,iBAAkB,EAGjC,IAAMC,EAAehB,EAAKiB,gBAAgBZ,EAASC,EAAOC,GAGxCG,EAAWQ,IAAIhC,EAAQ,WACxC,IAAMiC,EAAgBlB,KAAKmB,OAAOf,EAASM,EAAgBK,GAE3DhB,EAAKb,SAASkC,IAAIF,EAAcG,cAAe,CAC9CjB,QAAAA,EACAM,eAAAA,EACAK,aAAAA,EACAG,cAAAA,GAEF,GAGAnB,EAAKuB,UAAUlB,EAASC,EACzB,EACD,EAACR,EAGD0B,MAAA,WAECxC,KAAKa,MACN,EAACC,EAGD2B,GAAA,SAAGC,EAAOC,GACJ3C,KAAKU,cAAcgC,KACvB1C,KAAKU,cAAcgC,GAAS,IAE7B1C,KAAKU,cAAcgC,GAAOE,KAAKD,EAChC,EAAC7B,EAED+B,KAAA,SAAKH,GAAgBI,IAAAA,EAAAC,UAChB/C,KAAKU,cAAcgC,IACtB1C,KAAKU,cAAcgC,GAAOtB,QAAQ,SAACuB,UAAYA,EAAOK,WAAAC,EAAAA,GAAAA,MAAAC,KAAAJ,EAAA,GAAS,EAEjE,EAAChC,EAGDU,WAAA,SAAWH,GACV,OAAIrB,KAAKmD,cAAc9B,EAAS,CAAC,yBAA2BA,EAAQ+B,aAAa,yBAEzE/B,EAAQgC,cACLhC,EAAQ+B,aAAa,yBAEVE,SAASC,cAAclC,EAAQmC,QAAQC,mBAI3DC,QAAQC,MACkDtC,yDAAAA,EAAQmC,QAAQC,iBAEnEpC,GAIDA,CAET,EAACP,EAGDW,UAAA,SAAUJ,GACT,OAAOA,EAAQ+B,aAAa,wBAA0B/B,EAAQmC,QAAQI,eAAiB5D,KAAKE,MAC7F,EAACY,EAGDc,kBAAA,SAAkBP,EAASC,GAC1B,IAAMuC,EAAc7D,KAAK8D,eAAezC,GAChC0C,EAAW/D,KAAKgE,qBAAqB3C,GAArC0C,OAER,OAAAE,EACIJ,CAAAA,EAAAA,GACHK,OAAQlE,KAAKmD,cAAc9B,EAAS,CAAC,qBAAsB,0BAA4B,OAAS,KAChG8C,IACCnE,KAAKmD,cAAc9B,EAAS,CAAC,yBAC5BrB,KAAKmD,cAAc9B,EAAS,CAAC,0BAC3B,OACA,KACJ+C,GACCpE,KAAKmD,cAAc9B,EAAS,CAAC,6BACG,MAA/BrB,KAAKqE,aAAahD,IAAmD,OAA/BrB,KAAKqE,aAAahD,GAEtD,KADA0C,EAEJO,GACEtE,KAAKmD,cAAc9B,EAAS,CAAC,6BAC7BrB,KAAKmD,cAAc9B,EAAS,CAAC,8BACG,MAA/BrB,KAAKqE,aAAahD,IAAmD,OAA/BrB,KAAKqE,aAAahD,IACvD0C,EACA,MAEN,EAACjD,EAGDmB,gBAAA,SAAgBZ,EAASC,EAAOC,GAASgD,IAAAA,OAClCC,EAAYxE,KAAKyE,aAAapD,GAC9BqD,EAAmB1E,KAAK2E,oBAAoBtD,GAC5CuD,EAAW5E,KAAKmD,cAAc9B,EAAS,CAAC,yBACxCwD,EAAkBxD,EAAQyD,aAAa,sBACvCC,EAAoB1D,EAAQyD,aAAa,0BAGzCE,EAAsB,SAACC,EAAMC,GAC9BL,GACHM,OAAOC,cACN,IAAIC,YAAYR,EAAiB,CAChCS,OAAQ,CACPC,OAAQlE,EACR6D,UAAyB,IAAdA,EAAkB,OAAS,KACtCD,KAAAA,KAKL,EAiBA,OAAAhB,EAAA,CAAA,EACIO,EACHJ,CAAAA,EAAGpE,KAAKwF,KAAKnE,GACbiD,EAAGtE,KAAKyF,KAAKpE,GACbqE,KAAM,OACNpD,cAAe,CACdf,QAASqD,EAAWvD,EAAUE,EAC9BiB,MAAOxC,KAAK2F,SAAStE,GACrBuE,IAAK5F,KAAK6F,OAAOxE,GACjByE,qBAAqB,EACrBC,IAAKrB,EAAiBqB,IACtBC,WAAYtB,EAAiBsB,WAC7BC,MAAOjG,KAAKkG,SAAS7E,GACrB8E,QAASnG,KAAKmD,cAAc9B,EAAS,CAAC,wBACtC+E,SAAU,SAAAC,GACT,IAAIC,EAAWD,EAAKC,SAASC,QAAQ,GACrClF,EAAQmF,MAAMC,YAAY,qBAAsBH,GAE5CvB,GAhCuB,SAACuB,EAAUpB,GACpCH,GACHI,OAAOC,cACN,IAAIC,YAAYN,EAAmB,CAClCO,OAAQ,CACPjE,QAASA,EACTiF,SAAUA,EACVpB,UAAyB,IAAdA,EAAkB,OAAS,QAK3C,CAqBIwB,CAAsBJ,EAAUD,EAAKnB,UAEvC,EACAyB,SAAU,SAAAN,GACJA,EAAKO,UACTvF,EAAQmF,MAAMC,YAAY,qBAAsB,EAElD,EACAI,QAAS,SAAAC,GAAG,IAAA5B,EAAS4B,EAAT5B,UACX7D,EAAQ0F,UAAU7E,IAAIqC,EAAKjE,eAAgBiE,EAAKhE,eAC5CqE,GACHvD,EAAQ0F,UAAU7E,IAAIqC,EAAK/D,YAAa+D,EAAK9D,YAE9CuE,EAAoB,UAAWE,GAC/BX,EAAK1B,KAAK,UAAWxB,EACtB,EACA2F,QAAS,SAAAC,OAAG/B,EAAS+B,EAAT/B,UACX7D,EAAQ0F,UAAUG,OAAO3C,EAAKjE,gBAC1BsE,GACHvD,EAAQ0F,UAAUG,OAAO3C,EAAK/D,aAE/BwE,EAAoB,UAAWE,GAC/BX,EAAK1B,KAAK,UAAWxB,EACtB,EACA8F,YAAa,SAAAC,GAAG,IAAAlC,EAASkC,EAATlC,UACf7D,EAAQ0F,UAAU7E,IAAIqC,EAAKjE,gBACvBsE,GACHvD,EAAQ0F,UAAU7E,IAAIqC,EAAK/D,aAE5BwE,EAAoB,cAAeE,GACnCX,EAAK1B,KAAK,cAAexB,EAC1B,EACAgG,YAAa,SAAAC,GAAmB,IAAhBpC,EAASoC,EAATpC,UACf7D,EAAQ0F,UAAUG,OAAO3C,EAAKjE,gBAC1BsE,GACHvD,EAAQ0F,UAAUG,OAAO3C,EAAK/D,aAE/BwE,EAAoB,cAAeE,GACnCX,EAAK1B,KAAK,cAAexB,EAC1B,IAGH,EAACP,EAGD6D,oBAAA,SAAoBtD,GACnB,OAAIA,EAAQ+B,aAAa,wBACjB,CAAE2C,KAAK,EAAMC,YAAY,GAEzB,CAAED,KAAK,EAAOC,YAAY,EAEnC,EAAClF,EAGDqC,cAAA,SAAc9B,EAASkG,GACtB,OAAOA,EAAMC,MAAM,SAACC,GAAS,OAAApG,EAAQ+B,aAAaqE,EAAK,EACxD,EAAC3G,EAGDgD,eAAA,SAAezC,GACd,OAAOA,EAAQ+B,aAAa,sBAAwBsE,KAAKC,MAAMtG,EAAQmC,QAAQoE,cAAgB,EAChG,EAAC9G,EAGD2D,aAAA,SAAapD,GACZ,OAAOA,EAAQ+B,aAAa,oBAAsBsE,KAAKC,MAAMtG,EAAQmC,QAAQqE,YAAc,EAC5F,EAAC/G,EAGDgH,UAAA,SAAUzG,GACT,OAAOA,EAAQ+B,aAAa,wBAA0B2E,SAAS1G,EAAQmC,QAAQwE,gBAAkB,IAClG,EAAClH,EAGDuD,aAAA,SAAahD,GACZ,OAAOA,EAAQmC,QAAQyE,kBAAoB5G,EAAQmC,QAAQyE,kBAAoB,GAChF,EAACnH,EAGD0E,KAAA,SAAKnE,GACJ,OAAIA,EAAQ+B,aAAa,wBACjB,MAGPpD,KAAKmD,cAAc9B,EAAS,CAAC,6BACG,MAA/BrB,KAAKqE,aAAahD,IAAmD,OAA/BrB,KAAKqE,aAAahD,QAF1D,EAIYrB,KAACkI,mBAAmB7G,EAEjC,EAACP,EAGD2E,KAAA,SAAKpE,GACJ,OAAIA,EAAQ+B,aAAa,wBACjB,MAGNpD,KAAKmD,cAAc9B,EAAS,CAAC,6BAC7BrB,KAAKmD,cAAc9B,EAAS,CAAC,8BACG,MAA/BrB,KAAKqE,aAAahD,IAAmD,OAA/BrB,KAAKqE,aAAahD,IAE/CrB,KAACkI,mBAAmB7G,QALhC,CAOD,EAACP,EAGDkD,qBAAA,SAAqB3C,GAEpB,GAAIA,EAAQ+B,aAAa,wBACxB,MAAO,CAAEW,OAAQ,KAAMoE,SAAU,MAGlC,IAAIpE,EAAS,KACToE,EAAW,KAETC,EADiBpI,KAAKwB,WAAWH,GACFgH,aAErC,GAAIhH,EAAQ+B,aAAa,wBAAyB,CACjD,IAAAkF,EAAqCjH,EAAQmC,QAAQwE,eAAeO,MAAM,KAAnEC,EAAWF,EAAEG,GAAAA,EAAaH,EAAA,GAKhCvE,EAFGyE,EAAYE,OAAOC,SAAS,KACNC,WAAWJ,GAAe,IACvBJ,EAEnBQ,WAAWJ,GAMpBL,EAFGM,EAAcC,OAAOC,SAAS,KACNC,WAAWH,GAAiB,IACvBL,EAErBQ,WAAWH,EAExB,CAEA,MAAO,CAAE1E,OAAAA,EAAQoE,SAAAA,EAClB,EAACrH,EAGDoH,mBAAA,SAAmB7G,GAClB,IAAQ8G,EAAanI,KAAKgE,qBAAqB3C,GAAvC8G,SACFU,EAAiB1D,OAAO2D,YAC1BC,EAAc1H,EAAQmC,QAAQwF,cAC9BC,EAAqB,EAGzB,GAAIF,GAAeA,EAAYG,SAAS,KAAM,CAC7C,IAAAC,EAA4BJ,EAAYR,MAAM,KAAKa,IAAIR,YAIvDK,EAJwBE,EAGxBJ,GACmC,IAAOF,GAD1CE,EAHYI,EAAA,IAOM,IACjBF,IAAuB,EAEzB,MACCF,EAAcH,WAAWG,GAAe,KAGzC,GAAI/I,KAAKmD,cAAc9B,EAAS,CAAC,uBAAwB,CACxD,IAAMgI,EAAiBrJ,KAAKwB,WAAWH,GACjCiI,EAAeC,KAAKC,IAAIH,EAAehB,aAAehH,EAAQgH,cACpE,OAAOrI,KAAKmD,cAAc9B,EAAS,CAAC,2BAA6BiI,EAAeA,CACjF,CAAO,OAAItJ,KAAKmD,cAAc9B,EAAS,CAAC,wBAEhB0H,EADD1H,EAAQgH,aACuBY,EAE9B,OAAbd,EACHA,OADD,CAGR,EAACrH,EAGDoF,SAAA,SAAS7E,GACR,OAAIrB,KAAKmD,cAAc9B,EAAS,CAAC,yBACzB0G,SAAS1G,EAAQmC,QAAQiG,cAIlC,EAAC3I,EAGD6E,SAAA,SAAStE,GACR,GAAIA,EAAQ+B,aAAa,wBAAyB,CACjD,IAAIsG,EAAe,EAEnB,GAAIrI,EAAQ+B,aAAa,wBAAyB,KACjDuG,EAAqCtI,EAAQmC,QAAQwE,eAAeO,MAAM,KAC1EmB,EAAed,WADGe,EAAElB,GAErB,CAEA,OAAQpH,EAAQmC,QAAQoG,cAAgBvI,EAAQmC,QAAQoG,cAAgB,WAAa,KAAOF,CAC7F,CAAO,GACN1J,KAAKmD,cAAc9B,EAAS,CAAC,uBAAwB,0BACtB,MAA/BrB,KAAKqE,aAAahD,KACjBrB,KAAKmD,cAAc9B,EAAS,CAAC,sBAAuB,yBACpD,CACDwI,IAAOrB,EAA8BnH,EAAQmC,QAAQwE,eAAeO,MAAM,KAAxD,GAIlB,OAHsBK,WAAWJ,GAAe,EAAI,QAAUA,EAAc,UAGrEsB,SACR,CACC,OAAOzI,EAAQmC,QAAQoG,cAAgBvI,EAAQmC,QAAQoG,cAAgB,YAEzE,EAAC9I,EAGD+E,OAAA,SAAOxE,GACN,GAAIA,EAAQ+B,aAAa,wBAAyB,CACjD,IAAM7B,EAAUvB,KAAKwB,WAAWH,GAC5BqI,EAAe,EAEnB,GAAIrI,EAAQ+B,aAAa,wBAAyB,KACjD2G,EAAqC1I,EAAQmC,QAAQwE,eAAeO,MAAM,KAC1EmB,EAAed,WADkBmB,EACjCL,GACD,CAIA,OAAQrI,EAAQmC,QAAQwG,YAAc3I,EAAQmC,QAAQwG,YAAc,MAF7CzI,EAAQ0I,aAAe5I,EAAQ4I,aAAeP,EAGtE,CAAO,GAAI1J,KAAKmD,cAAc9B,EAAS,CAAC,0BAA4BA,EAAQ+B,aAAa,qBAAsB,CAC9G,IAAM8G,EAAiBlK,KAAKkI,mBAAmB7G,GAG/C,OAFqBrB,KAAKgE,qBAAqB3C,GAE/C,UAAgB6I,GAAkB,EAAI,KAAO,MAAOX,KAAKC,IAAIU,GAAe,MAC7E,CAAO,OACNlK,KAAKmD,cAAc9B,EAAS,CAAC,uBAAwB,0BACtB,MAA/BrB,KAAKqE,aAAahD,KACjBrB,KAAKmD,cAAc9B,EAAS,CAAC,oBAAqB,yBAG7B,WADeA,EAAQmC,QAAQwE,eAAeO,MAAM,KAC1E,GAGOuB,OAEAzI,EAAQmC,QAAQwG,YAAc3I,EAAQmC,QAAQwG,YAAc,YAErE,EAAClJ,EAGDyB,UAAA,SAAUlB,EAASC,GAClB,GAAKtB,KAAKK,OAAUL,KAAKmD,cAAc9B,EAAS,CAAC,wBAAjD,CAEA8I,IACIC,EACAC,EAFItG,EAAqB/D,KAAKgE,qBAAqB3C,GAA/C0C,OAIR,GAAI/D,KAAKmD,cAAc9B,EAAS,CAAC,wBAAyB,KAAAiJ,EACZjJ,EAAQmC,QAAQwF,cAAcT,MAAM,KAAhF6B,EAAeE,KAAED,EAAuBC,EAAA,EAC1C,CAEA,IAAM/C,EAAQlG,EAAQmC,QAChB+G,EAAWvK,KAAKmD,cAAc9B,EAAS,CAAC,wBACxCmJ,EAAYxK,KAAKmD,cAAc9B,EAAS,CAAC,yBACzCoJ,EAAYzK,KAAKmD,cAAc9B,EAAS,CAAC,yBACzCqJ,EAAa1K,KAAKmD,cAAc9B,EAAS,CAAC,0BAEhDqC,QAAQiH,MAA8CrJ,yCAAAA,EAAQ,GAAC,KAC/DoC,QAAQkH,IAAI,CACXvJ,QAASA,EACTE,QAASvB,KAAKwB,WAAWH,GACzBwJ,aAAc7K,KAAK2F,SAAStE,GAC5ByJ,WAAY9K,KAAK6F,OAAOxE,GACxB0J,KAAM/K,KAAKmD,cAAc9B,EAAS,CAAC,uBACnC2J,aAAcjH,EACdkH,YAAajL,KAAKkI,mBAAmB7G,GACrC6J,MAAOlL,KAAKkG,SAAS7E,GACrBnB,OAAQF,KAAKyB,UAAUJ,GACvB8J,MAAOZ,EACD3B,WACJwB,EAAkB/I,EAAQ4I,aACzBI,EAA0B,IAAOlF,OAAO2D,aACzC,KAAKF,WAAWwB,GAAgB,sBAAsBxB,WAAWyB,GAAwB,4BACxF,KACHnF,UAAWlF,KAAKmD,cAAc9B,EAAS,CAAC,4BACrCkG,EAAMU,kBACN,IACHmD,OAAQZ,EACRa,QAASX,EACTY,OAAQb,EACR5G,YAAa7D,KAAK8D,eAAezC,GACjCmD,UAAWxE,KAAKyE,aAAapD,GAC7BkK,YAAavL,KAAKmD,cAAc9B,EAAS,CAAC,uBACvCkG,EAAMiE,aACN,OAGa,CAChB,CAACC,UAAWzL,KAAKmD,cAAc9B,EAAS,CAAC,0BAA4BkJ,EAAUmB,QAAS,oDACxF,CAACD,UAAWjB,IAAcxK,KAAKmD,cAAc9B,EAAS,CAAC,yBAA2BrB,KAAKmD,cAAc9B,EAAS,CAAC,uBAAwBqK,QAAS,6EAChJ,CAACD,UAAWhB,GAAaF,EAAUmB,QAAS,2DAC5C,CAACD,UAAWhB,GAAazK,KAAKmD,cAAc9B,EAAS,CAAC,0BAA4BrB,KAAKmD,cAAc9B,EAAS,CAAC,sBAAuBqK,QAAS,oFAC/I,CAACD,UAAWf,KAAgB1K,KAAKmD,cAAc9B,EAAS,CAAC,wBAA0BrB,KAAKmD,cAAc9B,EAAS,CAAC,0BAA4BoJ,GAAaF,GAAWmB,QAAS,qHAC7K,CAACD,UAAWlB,GAAYC,EAAWkB,QAAS,8DAC5C,CAACD,UAA0C,MAA/BzL,KAAKqE,aAAahD,IAAoBmJ,EAAWkB,QAAS,6DAG9DtK,QAAQ,SAAAuK,GAAW,OAAAA,EAAQF,WAAa/H,QAAQkI,KAAKD,EAAQD,QAAQ,GAC9EhI,QAAQmI,UAvDR1B,CAwDD,EAACrJ,EAGDgL,MAAA,SAAMC,GACL,GAA8B,iBAAnBA,EAGV,OADaC,MAAMC,KAAKjM,KAAKG,SAAS+L,QAC1BH,GAGZ,IAAIxK,EAAU,KAMd,OALAvB,KAAKG,SAASiB,QAAQ,SAAC+K,EAAOC,GACzBD,EAAM9K,UAAY0K,IACrBxK,EAAU6K,EAEZ,GACO7K,CAET,EAACT,EAGDuL,QAAA,WACCC,cAAcD,UAGdrM,KAAK6C,KAAK,UACX,EAAC/B,EAGDyL,QAAA,WAECvM,KAAKwM,OAGLF,cAAcG,SAASrL,QAAQ,SAACG,UAAYA,EAAQmL,MAAM,GAG1DJ,cAAcD,UAGdrM,KAAKa,OAGLb,KAAK6C,KAAK,UACX,EAAC/B,EAGD0L,KAAA,SAAKjH,GACJ,QADU,IAANA,IAAAA,EAAS,MACTA,EAAQ,CAEX,IAAMoH,EAAgB3M,KAAKG,SAASyM,IAAIrH,GACpCoH,IACHA,EAAcxK,cAAcuK,OAC5B1M,KAAKG,gBAAgBoF,GAEvB,MAECvF,KAAKG,SAASiB,QAAQ,SAAAyL,GAAgBA,EAAb1K,cACVuK,MACf,GACA1M,KAAKG,SAAS2M,QAIf9M,KAAK6C,KAAK,OAAQ0C,EACnB,EAACzE,EAsBDiM,QAAA,WAEC/M,KAAKwM,OACLxM,KAAKG,SAAW,IACjB,EAACL,CAAA"}